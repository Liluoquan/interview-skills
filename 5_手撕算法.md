# 算法总结

## 十大排序算法

<img src="https://s1.328888.xyz/2022/05/02/AVhu4.png" alt="复杂度分析" style="zoom: 67%;" />

### 冒泡排序

- 基本思路：一边比较一边向后两两交换，将最大值 / 最小值冒泡到最后一位，每轮遍历后收缩待排序区间
- 优化：使用一个**变量记录当前轮次的比较是否发生过交换**，如果没有发生交换表示已经有序，不再继续排序

```c++
/*
* 冒泡排序
* 比较交换相邻元素
* 思路简单，仅学习用
*/
class Bubble
{
public:
    void mysort(vector<int> &nums)
    {
        int n = nums.size();
        for (int i = 0; i < n - 1; i++)
        {
            for (int j = 0; j < n - i - 1; j++)
            {
                if (nums[j] > nums[j + 1])
                {
                    int temp = nums[j];
                    nums[j] = nums[j + 1];
                    nums[j + 1] = temp;
                }
            }
        }
    }
};

int main()
{
    vector<int> nums = {9, 7, 5, 3, 1, 0, 8, 4, 6, 2};
    Bubble bubble;
    bubble.mysort(nums);
    for (int num : nums)
    {
        cout << num << " ";
    }
    return 0;
}

```

### 选择排序

- 基本思路：双重循环遍历数组，每经过一轮比较，找到最小元素的下标，将其交换至**当前待排序区间**的首位。
- 优化：既然每轮遍历时找出了最小值，何不把最大值也顺便找出来呢？这就是二元选择排序的思想。使用二元选择排序，**每轮选择时记录最小值和最大值**，可以把数组需要遍历的范围缩小一倍。

```
/*
* 选择排序
* 思路：找最小元素，放到最终位置
* 特点：时间：O(n²)、非稳定排序
* 适用：数据量少
*/
class Select
{
public:
    void mysort(vector<int> &nums)
    {
        int n = nums.size();
        for (int i = 0; i < n - 1; i++)
        {
            int minPos = i;
            for (int j = i + 1; j < n; j++)
            {
                if (nums[j] < nums[minPos])
                {
                    minPos = j;
                }
            }
            int temp = nums[i];
            nums[i] = nums[minPos];
            nums[minPos] = temp;
        }
    }
};

int main()
{
    vector<int> nums = {9, 7, 5, 3, 1, 0, 8, 4, 6, 2};
    Select select;
    select.mysort(nums);
    for (int num : nums)
    {
        cout << num << " ";
    }
    return 0;
}
```

**插入排序**

- 基本思想：有新数字加入时，将新数字插入合适的位置
- **交换法：**在新数字插入过程中，不断与前面的数字交换，直到找到自己合适的位置。
- **移动法：**在新数字插入过程中，与前面的数字不断比较，前面的数字不断向后挪出位置，当新数字找到自己的位置后，插入一次即可。

```c++
/*
* 插入排序
* 思路：抓牌一样，插入当前手牌中的适当位置
* 特点：时间：O(n²)
* 适用：基本有序
*/
class Insert
{
public:
    void mysort(vector<int> &nums)
    {
        int n = nums.size();
        for (int i = 1; i < n; i++)
        {
            int pos = i - 1;
            int cur = nums[i];
            while (pos >= 0 && cur < nums[pos])
            {
                nums[pos + 1] = nums[pos];
                pos--;
            }
            nums[pos + 1] = cur;
        }
    }
};
int main()
{
    vector<int> nums = {9, 7, 5, 3, 1, 0, 8, 4, 6, 2};
    Insert insert;
    insert.mysort(nums);
    for (int num : nums)
    {
        cout << num << " ";
    }
    return 0;
}
```

### 希尔排序

希尔排序本质上是对插入排序的一种优化，它利用了插入排序的简单，又**克服了插入排序每次只交换相邻两个元素**的缺点。它的基本思想是：

- 将待排序数组按照一定的间隔分为多个子数组，每组分别进行插入排序。这里按照间隔分组指的不是取连续的一段数组，而是**每跳跃一定间隔取一个值组成一组**
- **逐渐缩小间隔**进行下一轮排序
- 最后一轮时，取**间隔为 1，也就相当于直接使用插入排序**。但这时经过前面的「宏观调控」，数组已经基本有序了，所以此时的插入排序只需进行少量交换便可完成

```c++
/*
* 希尔排序
* 思路：间隔分组+自定义排序（这里给出的是冒泡）
* 特点：时间：O(nlogn)、非稳定排序
* 适用：数据量大
*/
class Shell
{
public:
    void mysort(vector<int> &nums)
    {
        int n = nums.size();
        int gap = n / 2;
        while (gap > 0)
        {
            for (int j = gap; j < n; j++)
            {
                int i = j;
                while (i >= gap && nums[i] < nums[i - gap])
                {
                    int temp = nums[i];
                    nums[i] = nums[i - gap];
                    nums[i - gap] = temp;
                    i -= gap;
                }
            }
            gap /= 2;
        }
    }
};
int main()
{
    vector<int> nums = {9, 7, 5, 3, 1, 0, 8, 4, 6, 2};
    Shell shell;
    shell.mysort(nums);
    for (int num : nums)
    {
        cout << num << " ";
    }
    return 0;
}
```

### 归并排序

- 基本思想：将两个有序的列表合并成一个有序列表

```c++
/*
* 归并排序
* 思路：递归思想
* 特点：时间：O(nlogn)、空间：O(n)——非原地
* 适用：不受数据影响，所需空间与n成正比
*/
class Merge
{
public:
    void mergeSort(vector<int>& nums, int left, int right) {
        if (left >= right)  return;
        
        int mid = left + (right - left) / 2;
        mergeSort(nums, left, mid);
        mergeSort(nums, mid + 1, right);
        merge(nums, left, right);
    }

    void merge(vector<int>& nums, int left, int right) {
        vector<int> temp(nums);
        // 合并两个有序数组，以中点为分割
        int mid = left + (right - left) / 2;
        int p = left, q = mid + 1;
        int index = left;
        // 归并
        while (p <= mid && q <= right) {
            if (nums[p] < nums[q]) {
                temp[index++] = nums[p++];
            }
            else {
                temp[index++] = nums[q++];
            }
        }
        // 将剩下的元素加入数组
        while (p <= mid)    temp[index++] = nums[p++];
        while (q <= right)  temp[index++] = nums[q++];

        // 恢复合并结果
        for (int i = left; i <= right; ++i) {
            nums[i] = temp[i];
        }
    }
};
int main()
{
    vector<int> nums = {9, 7, 5, 3, 1, 0, 8, 4, 6, 2};
    Merge merge;
    merge.mergeSort(nums, 0, nums.size() - 1);
    for (int num : nums)
        cout << num << " ";
    return 0;
}
```

#### 应用题

##### [剑指 Offer 51. 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

归并排序过程中，数组中是部分有序的，可以通过比较左右两边的数组来计算逆序对

```c++
class Solution {
public:
    int reversePairs(vector<int>& nums) {
        cnt = 0;
        mergeSort(nums, 0, nums.size() - 1);
        return cnt;
    }

private:
    int cnt;
    void merge(vector<int>& nums, int left, int mid, int right) {
        vector<int> temp(right - left + 1);
        int i = left, j = mid + 1;
        int pos = 0;
        while(i <= mid && j <= right) {
            if(nums[i] <= nums[j])
                temp[pos++] = nums[i++];
            else {
                temp[pos++] = nums[j++];
                cnt += mid - i + 1;  // 合并时，当左边大于右边，计算逆序对
            }
        }

        while(i <= mid) temp[pos++] = nums[i++];
        while(j <= right) temp[pos++] = nums[j++];
        for(int k = 0; k < temp.size(); ++k)
            nums[left + k] = temp[k];
    }

    void mergeSort(vector<int>& nums, int left, int right) {
        if(left >= right)   return;
        int mid = left + ((right - left) >> 1);
        mergeSort(nums, left, mid);
        mergeSort(nums, mid + 1, right);
        merge(nums, left, mid, right);
    }
};
```





### 快速排序

基本思想：

- 从数组中取出一个数，称之为基数（pivot）
- 遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域
- 将左右两个区域视为两个数组，重复前两个步骤，直到排序完成

```c++
/*
* 快速排序
* 思路：选择中轴元素，比它小的放左，比它大的放右（代码过程很像 小丑在扔三个小球）
* 特点：时间：O(nlogn)、空间：O(logn)、非稳定
* 适用：广泛（最快）
*/
class Quick
{
public:
    void mysort(vector<int> &nums, int left, int right)
    {
        if (start >= end)
            return;

        int mid = partition(nums, left, right);
        mysort(nums, left, mid - 1);
        mysort(nums, mid + 1, end);
    }
    
    int partition(vector<int>& nums, int left, int right) {
        int temp = nums[left];  // 将数组第一个元素作为基数，对数组进行划分
        while(left < right) {
            while(left < right && nums[right] >= temp)
                --right;
            nums[left] = nums[right];
            while(left < right && nums[left] <= temp)
                ++left;
            nums[right] = nums[left];
        }
        nums[left] = temp;
        return left;
    }
    
    // 为避免某些情况（每次选取的pivot都在头部或者尾部），pivot应取随机值
    int ramdomPartition(vector<int>& nums, int left, int right) {
        int mid = rand() % (right - left + 1) + left;
        swap(nums[mid], nums[left]);   //将这个随机值换到左边即可
        return partition(nums, left, right);
    }
};
int main()
{
    srand(time(0));
    vector<int> nums = {9, 7, 5, 3, 1, 0, 8, 4, 6, 2};
    Quick quick;
    quick.mysort(nums, 0, nums.size() - 1);
    for (int num : nums)
    {
        cout << num << " ";
    }
    return 0;
}
```



### 堆排序

基本思想：

- 用数列构建出一个大顶堆，取出堆顶的数字
- 调整剩余的数字，构建出新的大顶堆，再次取出堆顶的数字
- 循环往复，完成整个排序

```c++
/*
* 堆排序
* 思路：升序用大顶堆，每次调整后把最大的移出，再调整...
* 特点：时间：O(nlogn)、非稳定
* 适用：数据结构学习
*/
class Heap
{
public:
    void mysort(vector<int> &nums)
    {
        int n = nums.size();
        // （1）构造初始堆
        // 从第一个非叶子节点（倒数第二行最后一个）开始调整
        // 左右孩子节点中较大的交换到父节点中
        // 注意这里i是自底往上的！
        for (int i = n / 2 - 1; i >= 0; i--)
        {
            headAdjust(nums, n, i);
        }
        // （2）排序
        // 第一步.交换list[0]（最大）和list[i]
        // 第二步.此时list[0]在堆底，固定住，已排好
        // （for循环的i代表len，i--即每次把最后一个排好的忽略掉）
        // 第三步.把无缘无故提上来的幸运儿list[i]再adjust回它应该在的位置
        // （像石头沉入水底）
        // 下一个循环
        for (int i = n - 1; i > 0; i--)
        {
            // 交换
            swap(nums[i], nums[0]);
            // 调整
            headAdjust(nums, i, 0);
        }
    }
    // 辅助函数：调整堆
    // 参数说明：nums代表整个二叉树、len是nums的长度、 i代表三个中的根节点
    void headAdjust(vector<int> &nums, int len, int i)
    {
        int index = 2 * i + 1;
        // 这步while的意义在于把较小的沉下去，把较大的提上来
        while (index < len)
        {
            // （1）index指向左右孩子较大的那个
            if (index + 1 < len)
            {
                if (nums[index + 1] > nums[index]) // 说明还有右孩子
                {
                    index = index + 1;
                }
            }
            // （2）比较交换大孩子和根节点
            if (nums[index] > nums[i])
            {
                //交换
                swap(nums[i], nums[index]);
                //更新
                i = index;
                index = 2 * i + 1;
            }
            else
            {
                break;
            }
        }
    }
};
int main()
{
    vector<int> nums = {9, 7, 5, 3, 1, 0, 8, 4, 6, 2};
    Heap heap;
    heap.mysort(nums);
    for (int num : nums)
    {
        cout << num << " ";
    }
    return 0;
}

```

### 计数排序

基本思想：

- 数组中每个元素都是 [1, 9]区间内的整数。那么我们可以构建一个长度为9的数组用于计数，计数数组的下标分别对应区间内的 9个整数。

- 然后遍历待排序的数组，将区间内每个整数出现的次数统计到计数数组中对应下标的位置。最后遍历计数数组，将每个元素输出，输出的次数就是对应位置记录的次数。

```c++
/*
* 计数排序
* 思路：借助足够大的辅助数组，把数字排在一个相对位置不会错的地方，最后并拢
* 特点：时间：O(n+k)、空间：O(n+k)——非原地
* 适用：max和min的差值不大
*/
class Count
{
public:
    void mysort(vector<int> &nums, int min, int max)
    {
        vector<int> temp(max - min + 1);
        for (int num : nums)
        {
            temp[num - min]++;
        }
        int index = 0;
        for (int i = 0; i < temp.size(); i++)
        {
            int cnt = temp[i];
            while (cnt != 0)
            {
                nums[index] = i + min;
                index++;
                cnt--;
            }
        }
    }
};
int main()
{
    vector<int> nums = {9, 7, 5, 3, 1, 0, 8, 4, 6, 2};
    Count count;
    count.mysort(nums, 0, 9);
    for (int num : nums)
    {
        cout << num << " ";
    }
    return 0;
}
```

### 桶排序

基本思想：

- 将区间划分为 n 个相同大小的子区间，每个子区间称为一个桶
- 遍历数组，将每个数字装入桶中
- 对每个桶内的数字单独排序，这里需要采用其他排序算法，如插入、归并、快排等
- 最后按照顺序将所有桶内的数字合并起来

```c++
/*
* 桶排序
* 思路：先粗略分类分桶，再各桶排序
* 特点：时间：O(n+k)、空间：O(n+k)——非原地
* 适用：均匀分布的数据
*/
class Bucket
{
public:
    void mysort(vector<int> &nums)
    {
        //（1）初始化桶
        int n = nums.size();
        vector<list<int>> buckets(n);
        //（2）数据放入桶并完成排序
        for (int num : nums)
        {
            int index = getBucketIndex(num);
            insertSort(buckets[index], num);
        }
        //（3）从桶取数据，放入nums
        int index = 0;
        for (list<int> bucket : buckets)
        {
            for (int num : bucket)
            {
                nums[index] = num;
                index++;
            }
        }
    }
    //辅助函数一：获得桶的序号
    int getBucketIndex(int num)
    {
        return num / 3;
    }
    //辅助函数二：把数据插入对应桶(这里用的插入排序)
    void insertSort(list<int> &bucket, int num)
    {
        int n = bucket.size();
        bool flag = true;
        for (auto it = bucket.begin(); it != bucket.end(); it++)
        {
            if (num <= *it)
            {
                bucket.insert(it, num);
                flag = false;
                break;
            }
        }
        if (flag)
            bucket.push_back(num);
    }
};
int main()
{
    vector<int> nums = {9, 7, 5, 3, 1, 0, 8, 4, 6, 2};
    Bucket b;
    b.mysort(nums);
    for (int num : nums)
    {
        cout << num << " ";
    }
    return 0;
}

```



### 基数排序

基本思想：我们大脑中对日期排序的思维过程是：先看年份，再比较一下月份，最后比较具体几号。**利用多关键字进行排序**的思想就是基数排序。

- 找出数组中最大的数字的位数 maxDigitLength
- 获取数组中每个数字的基数
- 遍历 maxDigitLength 轮数组，每轮按照基数对其进行排序（每轮对基数进行排序非常适合使用我们在上面学习的**计数排序**算法）

```c++
/*
* 基数排序
* 思路：桶排序的一种。 按数位分桶：从低位开始 -> 分桶、收集 -> 下一位...
* 特点：时间：O(kn)、空间：O(n+k)——非原地
* 适用：max和min的差值不大
*/
class Radix
{
public:
    void mysort(vector<int> &nums, int d)
    {
        int p = 1;
        int n = nums.size();
        vector<vector<int>> buckets(10, vector<int>(n));
        vector<int> order(10);
        while (p < d)
        {
            //（1）进行一轮分桶
            for (int num : nums)
            {
                int index = num / p % 10;           //获取桶号
                buckets[index][order[index]] = num; // num放入index号桶的第
                order[index] 位置
                    order[index]++; //位置++
            }
            //（2）进行一轮排序
            int k = 0;
            for (int i = 0; i < 10; i++)
            {
                if (order[i] == 0)
                    continue;
                for (int j = 0; j < order[i]; j++)
                {
                    nums[k] = buckets[i][j];
                    k++;
                }
                order[i] = 0; //各桶计数器清零
            }
            p *= 10;
        }
    }
};
int main()
{
    vector<int> nums = {999, 765, 780, 215, 13, 66, 230, 450, 699, 21};
    Radix radix;
    radix.mysort(nums, 1000);
    for (int num : nums)
        cout << num << " ";
    return 0;
}
```



### 排序算法的比较，选择及其改进

- [ ] 从三个方向进行考虑：时间复杂度 + 空间复杂度 + 稳定性

- **平均时间复杂度**
  1. $$O(n^2)$$：直接插入排序、简单选择排序、冒泡排序
  2. $$O(nlog_2(n))$$：堆排序、归并排序、快速排序
  3. $$O(dn)$$：基数排序
- **空间复杂度**
  1. $$O(rd+n)$$：基数排序
  2. $$O(nlog_2(n))$$：快速排序
  3. $$O(1)$$：其他排序
- **稳定性**
  1. **稳定**：直接插入排序、冒泡排序、归并排序、基数排序
  2. **不稳定**：希尔排序、直接选择排序、堆排序、快速排序



> 改进方法

1. 将简单选择排序改进为二元选择排序，每次循环选出最大值和最小值。
2. 在冒泡排序中加入标志，记录某一趟排序过程中是否有数据交换。没有的话直接退出循环。
3. 快速排序中，随机取基数，保证平均时间复杂度





## 七大查找算法

### 顺序查找

顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。

**顺序查找的时间复杂度为O(n)。**



### 二分查找

**说明：元素必须是有序的，如果是无序的则要先进行排序操作。**



### 插值查找

**基本思想：**基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。



### 斐波那契查找

**基本思想：**也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。



### 树表查找

二叉搜索树（BST）、2-3树、红黑树、B/B+树

**基本思想：**二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。 



### 分块查找

分块查找又称索引顺序查找，它是顺序查找的一种改进方法。

**算法思想：**将n个数据元素"按块有序"划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须"按块有序"；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；



### 哈希查找

**算法思想：**哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。



## 数组相关

### 原地哈希

如果数组里面各个元素的大小都是可表达的（比如小于数组长度），那么就可以对数组的各个元素在元素组中进行映射（简单来说就是一个萝卜一个坑），从而在不浪费额外空间下，迅速找到重复元素。

通过不断交换，让元素放在正确的位置

**例题：**

1. [442. 数组中重复的数据](https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/)（中等）
2. [41. 缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/)（困难）
3. [448. 找到所有数组中消失的数字](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)（简单）

```c++
// 41. 缺失的第一个正数的题解
int firstMissingPositive(vector<int>& nums) {
    for(int i = 0; i < nums.size(); ++i) {
        // nums[i]与它应该在的位置的元素比较
        while(nums[i] > 0 && nums[i] <= nums.size() && nums[i] != nums[nums[i] - 1]) {
            swap(nums[i], nums[nums[i] - 1]);
        }
    }

    for(int i = 0; i < nums.size(); ++i) {
        if(nums[i] != i + 1)
            return i + 1;
    }

    return nums.size() + 1;
}
```



### N 数之和

手撕代码环节的常客了，这里简单记录一下，避免现场脑子抽风一下子忘了。

例题：

1. [1. 两数之和](https://leetcode.cn/problems/two-sum/)（找两个数之和为target，考虑先排序然后二分/双指针，难点是要返回原数组的下标）
2. [15. 三数之和](https://leetcode.cn/problems/3sum/)（排序后双指针）
3. [18. 四数之和](https://leetcode.cn/problems/4sum)





### 第 k 大/小的数

**这种题型两种思路：**

1. 如果数是一个一个输入进去的，可以考虑 `priority_queue` （大顶堆/小顶堆）
2. 如果是给定数组的话，更应该考虑快速排序 + 二分查找

**例题：**

1. [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

```c++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int left = 0, right = nums.size() - 1;
        while(left <= right) {
            int mid = randomPartition(nums, left, right);
            if (mid < nums.size() - k) {
                left = mid + 1;
            }
            else {
                right = mid - 1;
            }
        }

        return nums[left];
    }

private:
    int partition(vector<int>& nums, int left, int right) {
        int pivot = nums[left];
        while (left < right) {
            while (left < right && nums[right] >= pivot)
                --right;
            nums[left] = nums[right];
            while(left < right && nums[left] <= pivot)
                ++left;
            nums[right] = nums[left];
        }
        nums[left] = pivot;
        return left;
    }

    int randomPartition(vector<int>& nums, int left, int right) {
        int mid = rand() % (right - left + 1) + left;
        swap(nums[left], nums[mid]);
        return partition(nums, left, right);
    }
};
```





### 滑动窗口

**涉及连续子数组的问题，我们通常有两种思路：一是滑动窗口、二是前缀和。**

**定义**：滑动窗口，就是有一个大小可变的窗口，左右两端方向一致的向前滑动（右端固定，左端滑动；左端固定，右端滑动）。

**适用场景**：

1. 一般是字符串或者列表
2. 一般是要求最值（最大长度，最短长度等等）或者子序列

**例题**：

1. [643. 子数组最大平均数 I](https://leetcode-cn.com/problems/maximum-average-subarray-i/)
2. [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)
3. [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)
4. [1695. 删除子数组的最大得分](https://leetcode-cn.com/problems/maximum-erasure-value/)
5. [438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/ )和[567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)（两个基本是同一道题）
6. [1004. 最大连续1的个数 III](https://leetcode-cn.com/problems/max-consecutive-ones-iii/)和[1493. 删掉一个元素以后全为 1 的最长子数组](https://leetcode-cn.com/problems/longest-subarray-of-1s-after-deleting-one-element/)
7. [424. 替换后的最长重复字符](https://leetcode-cn.com/problems/longest-repeating-character-replacement/)和[1208. 尽可能使字符串相等](https://leetcode-cn.com/problems/get-equal-substrings-within-budget/)（前缀和的思想）
8. [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)
9. [剑指 Offer 59 - II. 队列的最大值](https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/) AND [剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof)（腾讯二面手撕，用一个队列记录最大值）
10. [904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)（用哈希表作为篮子）
11. [剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)

模板（伪代码）：

```c++
int templateofWindow(vector<int>& nums) {
    int start = 0, end = 0;
    int result = 0;

    // 遍历整个数组
    while(end < nums.size()) {
        
        // 处理当前右指针位置的数据
        if(/*当前位置的数据满足要求*/) {
            ++cntZero;
        }

        // 当前窗口不满足条件
        while(/*当前窗口不满足条件*/) {
            if(nums[start] == 0)
                --cntZero;
            // 右移左指针
            ++start;
        }

        // 计算当前窗口的大小
        result = max(result, end - start + 1);
        // 右移右指针
        ++end;
    }

    return result;
}
```



### 约瑟夫环问题

约瑟夫问题是个著名的问题：N个人围成一圈，第一个人从1开始报数，报M的将被杀掉，下一个人接着从1开始报。如此反复，最后剩下一个，求最后的胜利者。
例如只有三个人，把他们叫做A、B、C，他们围成一圈，从A开始报数，假设报2的人被杀掉。

**例题：**

1. [1823. 找出游戏的获胜者](https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/)
2. [剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)
3. 

<img src="https://assets.leetcode.com/uploads/2021/03/25/ic234-q2-ex11.png" alt="约瑟夫环示意图" style="zoom:67%;" />

- **队列模拟**

被淘汰的pop出队列，否则重新入队

```c++
int lastRemaining(int n, int m)
{
    queue<int> que;
    for (int i = 0; i < n; ++i)
    {
        que.push(i);
    }

    for (int i = 0; i < n - 1; ++i)
    {
        for (int j = 1; j < m; ++j)
        {
            int cur = que.front();
            que.pop();
            que.emplace(cur);
        }
        que.pop();
    }

    return que.front();
}
```

- **逆向思维**

约瑟夫环的递推公式
$$
f(N,M)=(f(N−1,M)+M) \% N
$$
$$f(N,M)$$表示，N个人报数，每报到M时杀掉那个人，最终胜利者的编号
$$f ( N − 1 , M )$$表示，N-1个人报数，每报到M时杀掉那个人，最终胜利者的编号

简单来说就是：

- 只有一人报数时，最后胜利者的编号一定是0，即f ( 1 , M )=0
- 而有两个人报数时，淘汰一个人后，相当于把胜利者的编号前移M位**（每杀掉一个人，下一个人成为头，相当于把数组向前移动M位）**
- 所以从后往前推就是将胜利者的编号后移M位

```c++
/*递归版*/
int lastRemaining(int n, int m)
{
    if (n == 0)
        return 0;
    return (lastRemaining(n - 1, m) + m) % n;
}

/*迭代版*/
int lastRemaining(int n, int m)
{
    int result = 0;
    // 从剩两个人开始倒推
    for (int i = 2; i <= n; ++i)
    {
        result = (result + m) % i;
    }

    return result;
}
```





### 二分查找（binary search）

主要题目提到有序，大概率是二分

或者是第 k 大/第 k 小，大概率是二分或者 minHeap/maxHeap

**主要搞清楚以下几个点：**

1. `while(left <= right)` 还是 `while(left < right)`

   有等号代表`[left, right]`，每次遍历需要改变左右指针 `left = mid + 1` 或 `right = mid - 1`

   没等号代表`[left, right)`，每次遍历仅需要改变左指针 `left = mid + 1`

2. 是只找一个还是找左右边界

   - 找一个，当 mid 满足条件就可以返回了
   - 找左右边界在 `mid == target` 时，仍需移动左右指针
   
3. 是以值域二分还是以下标二分



#### 基本操作

##### 找一个值

```c++
// 找一个
// [left, right]，左闭右闭
int getIndex(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if(nums[mid] == target) {
            return mid;
        }
        else if(nums[mid] < target) {
            left = mid + 1;
        }
        else {
            right = mid - 1;
        }
    }
    return -1;
}

// 递归版本
int getIndex(vector<int>& nums, int target, int left, int right) {
    if (left > right)	return -1;
    
    int mid = left + (right - left) / 2;
    if (nums[mid] > target) {
        return getIndex(nums, target, left, mid - 1);
    }
    else if (nums[mid] < target) {
        return getIndex(nums, target, mid + 1, right);
    }
    
    return mid;
}
```



##### 左边界或者右边界

```c++
int findLeftBounder(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    // int res = -1;
    while (left <= right) {
        int mid = left + ((right - left) >> 1);
        if (nums[mid] >= target) {
            right = mid - 1;
        }
        else {
            left = mid + 1;
        }
    }
    if (left >= nums.size() || nums[left] != target) {  // 找不到指定的值
        return -1;
    }

    // 根据判断条件，left左边的值都比left指向的值小，所以left是第一个小于等于target的位置
    return left;
}

int findRightBounder(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    // int res = -1;
    while (left <= right) {
        int mid = left + ((right - left) >> 1);
        if (nums[mid] > target) {
            right = mid - 1;
        }
        else {
            left = mid + 1;
        }
    }

    if (right >= nums.size() || nums[right] != target) {  // 找不到指定的值
        return -1;
    }

    // 根据判断条件，right右边的值都比right指向的值大，所以right是第一个大于等于target的位置
    return right;
}
```





#### 整体有序的二分查找

**例题（一维数组的二分查找）：**

1. [704.二分查找](https://leetcode-cn.com/link/?target=https%3A%2F%2Fprogrammercarl.com%2F0704.二分查找.html)
2. [35.搜索插入位置](https://leetcode-cn.com/link/?target=https%3A%2F%2Fprogrammercarl.com%2F0035.搜索插入位置.html)
3. [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

```c++
// 找一个
// [left, right]，左闭右闭
int getIndex(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if(nums[mid] == target) {
            return mid;
        }
        else if(nums[mid] < target) {
            left = mid + 1;
        }
        else {
            right = mid - 1;
        }
    }
    return -1;
}

// 找右边界
// 二分查找，寻找target的右边界（不包括target）
// 如果rightBorder为没有被赋值（即target在数组范围的左边，例如数组[3,3]，target为2），为了处理情况一
int getRightBorder(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
    int rightBorder = -2; // 记录一下rightBorder没有被赋值的情况
    while (left <= right) { // 当left==right，区间[left, right]依然有效
        int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
        if (nums[middle] > target) {
            right = middle - 1; // target 在左区间，所以[left, middle - 1]
        } else { // 当nums[middle] == target的时候，更新left，这样才能得到target的右边界
            left = middle + 1;
            rightBorder = left; // 边界包括target这句放前面就行
        }
    }
    return rightBorder;
}

// 找左边界
// 二分查找，寻找target的左边界leftBorder（不包括target）
// 如果leftBorder没有被赋值（即target在数组范围的右边，例如数组[3,3],target为4），为了处理情况一
int getLeftBorder(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
    int leftBorder = -2; // 记录一下leftBorder没有被赋值的情况
    while (left <= right) {
        int middle = left + ((right - left) / 2);
        if (nums[middle] >= target) { // 寻找左边界，就要在nums[middle] == target的时候更新right
            right = middle - 1;
            leftBorder = right; // 边界包括target这句放前面就行
        } else {
            left = middle + 1;
        }
    }
    return leftBorder;
}
```



#### 部分有序的二分查找

**例题（二维数组的二分查找）：**

1. [668. 乘法表中第k小的数](https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/)（值域二分）
2. [378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/)（值域二分）
2. [剑指 Offer 11. 旋转数组的最小数字](https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)（部分有序一维数组的二分查找）

```c++
// 378. 有序矩阵中第 K 小的元素
class Solution {
public:
    int findKthNumber(int m, int n, int k) {
        int left = 1, right = m * n;
        while(left <= right) {
            int mid = right - (right - left) / 2;
            // int mid = (right + left) / 2;
            if(numsBelowX(m, n, mid) < k) {
                left = mid + 1;
            }
            else {
                right = mid - 1;
            }
        }
        return left;
    }

private:
    int numsBelowX(int m, int n, int x) {
        int result = 0;
        for(int i = 1; i <= m ; ++i) {
            result += min(x / i, n);
        }

        return result;
    }
};

// 剑指 Offer 11. 旋转数组的最小数字
int minArray(vector<int>& numbers) {
    // 数组部分有序，考虑二分查找
    int left = 0, right = numbers.size() - 1;
    while(left <= right) {
        int mid = (left + right) / 2;
        if(numbers[mid] < numbers[right]) {  // 这里不能写right=mid-1，因为可能会跳出右区间的最小值
            right = mid;
        }
        else if(numbers[mid] > numbers[right]) { //此时最小值一定在左边区间
            left = mid + 1;
        }
        else { // 重复的话只能由从右边界开始试了
            --right;
        }
    }
    return numbers[left];
}
```



#### 值域二分：猜答案

例题：

1. [剑指 Offer II 073. 狒狒吃香蕉](https://leetcode.cn/problems/nZZqjQ/)
2. [275. H 指数 II](https://leetcode.cn/problems/h-index-ii/)
3. [611. 有效三角形的个数](https://leetcode.cn/problems/valid-triangle-number/)
4. [1011. 在 D 天内送达包裹的能力](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/)
5. [1482. 制作 m 束花所需的最少天数](https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/)
6. [719. 找出第 K 小的数对距离](https://leetcode.cn/problems/find-k-th-smallest-pair-distance/)（值域二分 + 滑动窗口）
5. [6118. 最小差值平方和](https://leetcode.cn/problems/minimum-sum-of-squared-difference/)（值域二分的难度天花板了）



```c++
// 6118. 最小差值平方和
class Solution {
private:
    bool check(vector<int> diff, int mid, int rest) {
        long long sum = 0;
        for(int i: diff) {
            sum += (max(i, mid) - mid);
        }
        return sum <= rest;          // 操作数小于k1+k2说明大值都可以缩小到mid
    }
public: 
    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {
        int n = nums1.size(), rest = k1 + k2;   // rest为剩余操作数，k1和k2是等价的
        long long sum = 0;
        vector<int> diff(n, 0);
        // 求差值数组
        for(int i = 0; i < n; ++i) {
            diff[i] = abs(nums1[i] - nums2[i]);
            sum += diff[i];
        }
        if(sum <= rest)  return 0;               // 如果差值数组加和小于k1+k2，说明差值数组可以全部变为0

        // 值域二分，找出较大值们能够缩到的最小目标值
        int target, left = 0, right = 100001;   
        while(left <= right) {
            int mid = left + (right - left) / 2;
            if(check(diff, mid, rest)) {
                target = mid;
                right = mid - 1;
            }else {
                left = mid + 1;
            }
        }
        // 将所有大于target的值变为target
        for(int i = 0; i < n; ++i) {
            if(diff[i] > target) {
                rest -= (diff[i] - target);      // 减去将该值变为target所需的操作数
                diff[i] = target;                // 更新该值为target
            }
        }
        // 如果剩余操作数大于0，说明还可以继续操作差值数组
        // 继续对大值们进行修改，此时数组中的大值均为target，那么就为target的项就减去1，操作数也减1
        for(int i = 0; i < n && rest > 0; ++i) {
            if(diff[i] == target) {
                --diff[i];
                --rest;
            }
        }
        
        long long res = 0;
        for (int i: diff)    res += 1ll * i * i;
        return res;
    }
};
```





### 子数组数量问题

**给定一个数组，求满足【条件】的子数组数量。**

注意点：

- `curLen` 表示：以 `nums[i]` 结尾的子数组长度，也表示以 `nums[i]` 结尾的子数组个数（如 `[1, 2, 3]` 中的 `curLen = 3` 表示了 `[3]、[2, 3]、[1, 2, 3]` 正好三个子数组）
- 满足条件时，增加长度 `curLen` ，否则重置长度 `curLen` 为 0 ；
- 条件为区间 [L,  R] ，最大元素满足大于等于L小于等于R的子数组个数 = 最大元素**小于等于R**的子数组个数 - 最大元素**小于L**的子数组个数



**例题：**

1. [795. 区间子数组个数](https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/)
2. 

```c++
// 统计 <= k 的子数组数目
int countSubArray (vector<int>& nums, int k) {
    int res = 0, curLen = 0;
    for(int i = 0; i < nums.size(); ++i) {
        if(nums[i] <= k) { //满足条件才增加长度
            ++curLen;
            res += curLen;
        }
        else {
            curLen = 0;
        }
    }

    return res;
}
```







### 单调栈（笔试和面试的难点）

单调栈用途不太广泛，只处理一种典型的问题，叫做 Next Greater Element。

当题目出现「找到最近一个比其大的元素」的字眼时，自然会想到「单调栈」。



**例题：**

1. [496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)（单调栈开始的地方）
2. [503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/)（环形数组）
3. [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)（有个动规优化的双指针，面试可能会要求优化）
4. [6119. 元素值大于变化阈值的子数组](https://leetcode.cn/problems/subarray-with-elements-greater-than-varying-threshold/)（周赛题，待理解）
3. [316. 去除重复字母](https://leetcode.cn/problems/remove-duplicate-letters/)（妙题，主要就是根据 cnt 来压栈出栈）
3. lc-901, 402, 581待整理

模板：

```c++
vector<int> nextGreaterElement(vector<int>& T) {
    vector<int> ans(T.size());
    stack<int> s; // 这里放元素索引，而不是元素
    for (int i = T.size() - 1; i >= 0; i--) {
        while (!s.empty() && T[s.top()] <= T[i]) {
            s.pop();
        }
        ans[i] = s.empty() ? 0 : s.top(); // 根据具体场景对索引执行操作
        s.push(i); // 加入索引，而不是元素
    }
    return ans;
}
```



解法参照：[代码随想录 (programmercarl.com)](https://programmercarl.com/0042.接雨水.html#单调栈解法)

```c++
int trap(vector<int>& height) {
    stack<int> stk;  // 存放下标
    stk.emplace(0);
    int area = 0;
    for(int i = 1; i < height.size(); ++i) {
        if(height[i] < height[stk.top()]) {
            stk.emplace(i);
        }
        else if(height[i] == height[stk.top()]) {
            stk.pop();
            stk.emplace(i);
        }
        else {
            while(!stk.empty() && height[i] > height[stk.top()]) {
                int mid = stk.top();
                stk.pop();
                if(!stk.empty()) {
                    int h = min(height[stk.top()], height[i]) - height[mid];
                    int w = i - stk.top() - 1;
                    area += w * h;
                }
            }
            stk.emplace(i);
        }
    }

    return area;
}
```



### 波峰波谷问题



例题：

1. [376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)
2. [剑指 Offer II 069. 山峰数组的顶部](https://leetcode.cn/problems/B1IidL/)（山峰不能在边界）
3. [162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/)（山峰可以在边界）
3. [1901. 寻找峰值 II](https://leetcode.cn/problems/find-a-peak-element-ii/)（二维数组的极大值查找，**二分法待整理**）

```cpp
// 二维数组的极大值查找，依次遍历，每次往增长的方向去
vector<int> findPeakGrid(vector<vector<int>>& mat) {
    int x = 0, y = 0;
    int m = mat.size(), n = mat[0].size();
    while (true) {
        if (x > 0 && mat[x - 1][y] > mat[x][y]) {
            --x;
        }
        else if (x < m - 1 && mat[x + 1][y] > mat[x][y]) {
            ++x;
        }
        else if (y > 0 && mat[x][y - 1] > mat[x][y]) {
            --y;
        }
        else if (y < n - 1 && mat[x][y + 1] > mat[x][y]) {
            ++y;
        }
        else {
            return {x, y};
        }
    }

    return {};
}
```





### 三向切分（三路快排）—待学习

例题：

1. [75. 颜色分类](https://leetcode.cn/problems/sort-colors/)
2. [324. 摆动排序 II](https://leetcode.cn/problems/wiggle-sort-ii/)



### 重叠区间问题

**待总结：区间合并 + 二分查找**

这种就两个思路：区间排序（截断数组）和线段树

**例题：**

1. [732. 我的日程安排表 III](https://leetcode.cn/problems/my-calendar-iii/)
2. [剑指 Offer II 074. 合并区间](https://leetcode.cn/problems/SsGoHC/)
3. [452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)
4. [729. 我的日程安排表 I](https://leetcode.cn/problems/my-calendar-i/)（区间 $[l_1,r_1)$ 和 $[l_2,r_2)$ 不重叠的条件：$l_2{\geq}r_1 {\vee} l_1{\geq}r_2 $ ，由此可得重叠的条件：$l_2<r_1{\wedge}l_1<r_2$）
5. [715. Range 模块](https://leetcode.cn/problems/range-module/)
3. [2276. 统计区间中的整数数目](https://leetcode.cn/problems/count-integers-in-intervals/)

```c++
// 732. 我的日程安排表 III
// [start, end)，左闭右开，左端加1，右端截断（减一）
class MyCalendarThree {
public:
    MyCalendarThree() {

    }
    
    int book(int start, int end) {
        int res = 0;
        int maxBook = 0;
        ++cnt[start];
        --cnt[end];
        for(auto& [_, freq] : cnt) {
            maxBook += freq;
            res = max(maxBook, res);
        }

        return res;
    }

private:
    map<int, int> cnt;
};
```



#### 日程安排表问题







### 二维数组的遍历问题

#### 对角线遍历

**例题**：[498. 对角线遍历](https://leetcode.cn/problems/diagonal-traverse/)

![img](https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg)

**思路**：

1. 遍历过程中， x + y 表示层数，偶数层向上遍历，奇数向下遍历。
2. x，y在没有超出上界之前，初始值取层数，超出以后就取上界

```c++
vector<int> findDiagonalOrder(vector<vector<int>>& mat) {
    int m = mat.size(), n = mat[0].size();
    // 遍历过程中， x + y表示层数，偶数层向上遍历，奇数向下遍历
    vector<int> res;
    for(int k = 0; k < m + n - 1; ++k) {
        if((k & 1) == 0) {
            int x = (k < m) ?  k : m - 1;
            int y = k - x;
            while(x >= 0 && y <= n - 1) {
                res.emplace_back(mat[x][y]);
                --x;
                ++y;
            }
        }
        else {
            int y = (k < n) ?  k : n - 1;
            int x = k - y;
            while(y >= 0 && x <= m - 1) {
                res.emplace_back(mat[x][y]);
                ++x;
                --y;
            }
        }
    }

    return res;
}
```





#### 螺旋遍历



### 数组中的环

例题：

1. [565. 数组嵌套](https://leetcode.cn/problems/array-nesting)（每个数只要在环里面，由该数开始计算环的长度都是一样的）





## 优先队列

用于找出范围内的最大值，这里记录一下题型，方便后期回顾：

1. [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)（数据流输入用堆，数组输入用快速排序）
2. [871. 最低加油次数](https://leetcode.cn/problems/minimum-number-of-refueling-stops/)（百度一面，贪心＋优先队列，也可以考虑动态规划）







## 二叉树相关

### 二叉树的定义（手撕时需要自己写）

```c++
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
```



### 二叉树的输入（ACM模式）

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

// 根据数组构造二叉树
TreeNode* construct_binary_tree(const vector<int>& vec) {
    vector<TreeNode*> vecTree (vec.size(), NULL);
    TreeNode* root = NULL;
    // 先把值放到正确的地方（按照层序遍历的顺序）
    for (int i = 0; i < vec.size(); i++) {
        TreeNode* node = NULL;
        if (vec[i] != -1) node = new TreeNode(vec[i]);
        vecTree[i] = node;
        if (i == 0) root = node;
    }
    // 将每个值与左右节点连接起来
    for (int i = 0; i * 2 + 2 < vec.size(); i++) {
        if (vecTree[i] != NULL) {
            vecTree[i]->left = vecTree[i * 2 + 1];
            vecTree[i]->right = vecTree[i * 2 + 2];
        }
    }
    return root;
}

// 层序打印打印二叉树
void print_binary_tree(TreeNode* root) {
    queue<TreeNode*> que;
    if (root != NULL) que.push(root);
    vector<vector<int>> result;
    while (!que.empty()) {
        int size = que.size();
        vector<int> vec;
        for (int i = 0; i < size; i++) {
            TreeNode* node = que.front();
            que.pop();
            if (node != NULL) {
                vec.push_back(node->val);
                que.push(node->left);
                que.push(node->right);
            }
            // 这里的处理逻辑是为了把null节点打印出来，用-1 表示null
            else vec.push_back(-1);
        }
        result.push_back(vec);
    }
    for (int i = 0; i < result.size(); i++) {
        for (int j = 0; j < result[i].size(); j++) {
            cout << result[i][j] << " ";
        }
        cout << endl;
    }
}

int main() {
    // 注意本代码没有考虑输入异常数据的情况
    // 用 -1 来表示null
    vector<int> vec = {4,1,6,0,2,5,7,-1,-1,-1,3,-1,-1,-1,8};
    TreeNode* root = construct_binary_tree(vec);
    // dosomething();
    print_binary_tree(root);
}
```



### 二叉树的遍历

#### 前序遍历

- ##### 迭代版

```c++
// 1、先访问到树的最底层，将沿路的节点压入栈并处理节点（一路向左）
// 2、处理最后一个左节点后，将右节点放入栈中
void preorderTraversal(TreeNode* root) {
	stack<TreeNode*> stk;
    TreeNode* cur = root;
    while(cur != nullptr || !stk.empty()) {
        // 一路向左
		while(cur != nullptr) {
            doSomething(cur->val); // 处理当前节点
            stk.push(cur);
            cur = cur->left;
        }
        
        cur = stk.top();
        stk.pop();
        cur = cur->right;
    }
}
```

- ##### 递归版

```c++
void preorderTraversal(TreeNode* root) {
    if(root == nullptr)	return;
    // 中（处理当前节点）
    doSomething(root->val);
    // 左
    preorderTraversal(root->left);
    // 右
    preorderTraversal(root->right);
}
```

#### 中序遍历

- ##### 迭代版

```c++
// 1、先访问到树的最底层，将沿路的节点压入栈（一路向左）
// 2、将栈中的中节点取出来处理
// 3、将右节点放入栈中
void inorderTraversal(TreeNode* root) {
    stack<TreeNode*> stk;
    TreeNode* cur = root;
    
    while(cur != nullptr || !stk.empty()) {
        // 一路向左
        while(cur != nullptr) {
            stk.push(cur);
            cur = cur->left;
        }
        
        cur = stk.top();
        stk.pop();
        doSomething(cur->val);	// 中
        // 右
        cur = cur->right;
    }
}
```

- ##### 递归版

```c++
void inorderTraversal(TreeNode* root) {
    if(root == nullptr)	return;
    
    inorderTraversal(root->left);	// 左
    doSomething(root->val);	// 中
    inorderTraversal(root->right); // 右
}
```

#### 后序遍历

- ##### 迭代版

```c++
// 1、将左节点全部放入栈中
void postorderTraversal(TreeNode* root) {
	stack<TreeNode*> stk;
    TreeNode *pre = nullptr, *cur = root;
    
    while(cur != nullptr || !stk.empty()) {
        // 一路向左
        while(cur != nullptr) {
            stk.push(cur);
            cur = cur->left;
        }
        
        cur = stk.top(); // 此处不出栈，遍历完右子树再出栈
        // 右子树不为空 且 没有遍历过
        if(cur->right != nullptr && cur->right != pre) {
            cur = cur->right;
        }
        else {
            stk.pop();
            doSomething(cur->val);	// 处理节点
            pre = cur;  // 表示该节点处理过了
            cur = nullptr;  // 避免节点重复入栈
        }
    }
}
```

- ##### 递归版

```c++
void postorderTraversal(TreeNode* root) {
    if(root == nullptr)	return;
    
    inorderTraversal(root->left);	// 左
    inorderTraversal(root->right);  // 右
    doSomething(root->val);	        // 中
}
```



#### 层序遍历

例题见：[代码随想录 (二叉树层序遍历)](https://programmercarl.com/0102.二叉树的层序遍历.html)，还是蛮多的

- 迭代版

```c++
// 1、记录队列的length
// 2、遍历队列length个节点并进行处理
// 3、将处理节点的左右节点放入队列中
void bfs(TreeNode* root) {
    queue<TreeNode*> que;
    if(root != nullptr)
        que.push(root);
    
    while(!que.empty()) {
        int size = que.size();
        // 遍历该层的所有节点
        while(size > 0) {
            TreeNode* cur = que.front();
            que.pop();
            
            doSomething(cur->val);	// 处理节点
            if(cur->left != nullptr)
                que.push(cur->left);
            if(cur->right != nullptr)
                que.push(cur->right);
            --size;
        }
    }
}
```

- 递归版

  基本思想就是在 dfs 的过程中，记录树的深度 `depth` ，然后深度相同的节点就是同一层的节点，具体遍历顺序按照需求来。

```c++
// 637. 二叉树的层平均值
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        vector<double> res;
        vector<int> count;
        dfs(root, 0, res, count);
        for (int i = 0; i < res.size(); ++i) {
            res[i] /= count[i];
        }

        return res;
    }

private:
    void dfs(TreeNode* root, int depth, vector<double>& sum, vector<int>& count) {
        if (root == nullptr)    return;
        
        if (depth < count.size()) {
            count[depth] += 1;
            sum[depth] += root->val;
        }
        else {
            count.emplace_back(1);
            sum.emplace_back(root->val);
        }

        dfs(root->left, depth + 1, sum, count);
        dfs(root->right, depth + 1, sum, count);
    }
};
```



### BST的二分查找

**例题：**

1. [面试题 04.06. 后继者](https://leetcode.cn/problems/successor-lcci/)

**基本思想：**

```
输入: root = [5,3,6,2,4,null,null,1], p = 6

      5
     / \
    3   6
   / \
  2   4
 /   
1

输出: null
```

BST的核心就是左小右大

要从BST里找一个数，就是大于target，就向左走（当然，**如果找大于target的第一个数还要一直往左走**，并且每次都记录一下节点），小于target，就向右走。

```c++
TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
    int target = p->val;
    TreeNode *cur = root, *result = nullptr;
    while(cur != nullptr) {
        if(cur->val > target) {
            result = cur;
            cur = cur->left;
        }
        else {
            cur = cur->right;
        }
    }

    return result;
}
```





### 二叉树的编码

**例题：**

1. [297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)

**流式思想**

考虑前序遍历，每个节点的值用`" "`隔开，空指针用`"#"`表示，然后使用`istringstream`每次读入一个节点。

```c++
class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        if(root == nullptr) return "#";

        return to_string(root->val) + " " + serialize(root->left) + " " + serialize(root->right);
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        istringstream ss(data);
        return mydeserialize(ss);
    }

private:
    TreeNode* mydeserialize(istringstream& ss) {
        string temp;
        ss >> temp;
        if(temp == "#") return nullptr;

        TreeNode* root = new TreeNode(stoi(temp));
        root->left = mydeserialize(ss);
        root->right = mydeserialize(ss);
        return root;
    }
};
```





## 链表相关

链表的题目都较为简单，这里只记录几个需要注意的点：

1. 如果操作当前节点必须要找前一个节点才能操作，考虑定义 dummyHead，来保证对头结点的操作。

### 链表的定义

```cpp
// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(nullptr) {}  // 节点的构造函数
};
```









## 图相关

### 建图模板
如果可以确定图中每个节点的范围，用邻接矩阵 `vector<int,unordered_set>`或 `vector<vector<int>>`，否则用邻接表`unordered_map<int,unordered_set>>`

### BFS和DFS的模板
DFS：需要记录路径信息（节点值、路径长度等）或只要找一条符合要求的路径
BFS：找最短路径

以下模板均以：[剑指 Offer II 105. 岛屿的最大面积](https://leetcode.cn/problems/ZL6zAn/)为例子



#### DFS模板

- 迭代形式（用栈实现）

```c++
int getArea(const vector<vector<int>>& grid, vector<vector<bool>>& visted, int i, int j) {
    // 队列存放点的坐标(i,j)
    stack<vector<int>> stk;
    int area = 0;
    stk.push({i, j});
    visted[i][j] = true;

    vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

    while(!stk.empty()) {
        vector<int> pos = que.front();
        stk.pop();
        ++area;

        for(vector<int>& dir : dirs) {
            int r = pos[0] + dir[0], c = pos[1] + dir[1];
            if(r >= 0 && r < grid.size()
               && c >= 0 && c < grid[0].size()
               && grid[r][c] == 1 && !visted[r][c]) {
                stk.push({r, c});
                visted[r][c] = true;
            }
        }
    }

    return area;
}
```



- 递归形式

```c++
int getArea(const vector<vector<int>>& grid, vector<vector<bool>>& visted, int i, int j) {
    int area = 1;
    visted[i][j] = true;
    vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    
    for(vector<int>& dir : dirs) {
        int r = pos[0] + dir[0], c = pos[1] + dir[1];
        if(r >= 0 && r < grid.size()
           && c >= 0 && c < grid[0].size()
           && grid[r][c] == 1 && !visted[r][c]) {
			area += getArea(gird, visited, r, c);
        }
    }
}
```



#### BFS模板

单纯的遍历：不需要记录队列的长度

```c++
int getArea(const vector<vector<int>>& grid, vector<vector<bool>>& visted, int i, int j) {
    // 队列存放点的坐标(i,j)
    queue<vector<int>> que;
    int area = 0;
    que.push({i, j});
    visted[i][j] = true;

    vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

    while(!que.empty()) {
        vector<int> pos = que.front();
        que.pop();
        ++area;

        for(vector<int>& dir : dirs) {
            int r = pos[0] + dir[0], c = pos[1] + dir[1];
            if(r >= 0 && r < grid.size()
               && c >= 0 && c < grid[0].size()
               && grid[r][c] == 1 && !visted[r][c]) {
                que.push({r, c});
                visted[r][c] = true;
            }
        }
    }

    return area;
}
```



统计层数：需要记录队列的长度

```c++
vector<pair<int, int>> dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
// 从 (srcX, srcY) 到 (dstX, dstY) 需要走的最小步数（也就是层数） 
int dfs(vector<vector<int>>& forest, int srcX, int srcY, int dstX, int dstY) {
    if(srcX == dstX && srcY == dstY)
        return 0;

    queue<pair<int, int>> que;
    int M = forest.size(), N = forest[0].size();
    int steps = 0;
    vector<vector<bool>> visited(M, vector<bool>(N, false));
    que.emplace(srcX, srcY);
    visited[srcX][srcY] = true;

    while(!que.empty()) {
        //每次到下一层，先把层数 +1 
        ++steps;
        int size = que.size();
        for(int i = 0; i < size; ++i) {
            pair<int, int> p = que.front();
            que.pop();
            int sx = p.first, sy = p.second;

            for(const pair<int, int>& dir : dirs) {
                int x = sx + dir.first;
                int y = sy + dir.second;

                if(x >= 0 && x < M && y >= 0 && y < N && 
                    !visited[x][y] && forest[x][y] != 0) {
                    if(x == dstX && y == dstY) //在下一层到达终点，直接返回steps
                        return steps;
                    visited[x][y] = true;
                    que.push({x, y});
                }
            }
        }
    }

    return -1;
}
```

### 基环树

基环树的特征：

1. 单向图
2. 每个点有且只有一条出边（内向树）/每个点有且只有一条入边（外向树）
3. **一个点到另一个点只有一条路径**



#### 找两个点的最短距离/最近中间节点

例题：

1. [6134. 找到离给定两个节点最近的节点](https://leetcode.cn/problems/find-closest-node-to-given-two-nodes/)（用BFS做也是可以的，不过要注意两个点同时BFS）

```cpp
// 6134. 找到离给定两个节点最近的节点
class Solution {
public:
    int closestMeetingNode(vector<int>& p, int x, int y) {
        int n = p.size();
        // d1:x能够到达所有点的距离
        // d2:y能够到达所有点的距离
        vector<int> d1(n, -1), d2(n, -1);
        d1[x] = d2[y] = 0;
        while (p[x] != -1) {
            // 说明进入环了
            if (d1[p[x]] != -1) break;
            d1[p[x]] = d1[x] + 1;
            x = p[x];
        }

        while (p[y] != -1) {
            // 说明进入环了
            if (d2[p[y]] != -1) break;
            d2[p[y]] = d2[y] + 1;
            y = p[y];
        }

        int res = -1, id = -1;
        for (int i = 0; i < n; ++i) {
            int a = d1[i], b = d2[i];
            if (a != -1 && b != -1) { // 说明x和y都能到达这个点
                if (res == -1 || res > max(a, b)) {
                    res = max(a, b);
                    id = i;
                }
            }
        }

        return id;
    }
};
```

#### 找最大/最小环的长度

例题：

1. [6135. 图中的最长环](https://leetcode.cn/problems/longest-cycle-in-a-graph/)（还有一种想法就是拓扑排序去除入度为0的点，剩下的点就是环，然后dfs计算环的长度即可）

```cpp
// 6135. 图中的最长环
class Solution {
    vector<int> p;
    vector<bool> vis;        // 表示当时节点是否被搜索过
    vector<int> in_stk;     // 表示这个点在当次搜索是否已经搜索过了4
    int res = -1;

private:
    void dfs(int i, int depth) {
        vis[i] = true;
        in_stk[i] = depth;

        int j = p[i];  // 下个点
        if (j != -1) {
            if (!vis[j]) {  // 下个点没有被搜索过 
                dfs(j, depth + 1);
            }
            else if (in_stk[j]) {  // 下个点是环中遍历过的点
                res = max(res, depth + 1 - in_stk[j]);
            }
        }

        in_stk[i] = 0;
    }

public:
    int longestCycle(vector<int>& edges) {
        p = edges;
        int n = edges.size();
        vis = vector<bool>(n, false);
        in_stk = vector<int>(n, 0);

        for (int i = 0; i < n; ++i) {
            if (!vis[i]) {
                dfs(i, 1);
            }
        }

        return res;
    }
};
```



### 存在状态变化方格的图搜索

这种问题需要多维护一个数组来记录代价，或者自己创建结构体维护状态。

例题：

1. [1368. 使网格图至少有一条有效路径的最小代价](https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/)
1. [对称飞行器_阿里巴巴笔试题](https://www.nowcoder.com/questionTerminal/ef231526f822489d879949226b4bed65)

```c++
// Dijkstra 算法
using PII = pair<int, int>;

class Solution {
private:
    static constexpr int dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

public:
    int minCost(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<int> dist(m * n, INT_MAX);   // 当前点到起点的代价
        vector<int> seen(m * n, 0);         // 记录当前点是否遍历过，避免重复遍历
        dist[0] = 0;
        priority_queue<PII, vector<PII>, greater<PII>> q;
        q.emplace(0, 0);
        
        while (!q.empty()) {
            auto [cur_dis, cur_pos] = q.top();
            q.pop();
            if (seen[cur_pos]) {
                continue;
            }
            seen[cur_pos] = 1;
            int x = cur_pos / n;
            int y = cur_pos % n;
            for (int i = 0; i < 4; ++i) {
                int nx = x + dirs[i][0];
                int ny = y + dirs[i][1];
                int new_pos = nx * n + ny;
                // 当前的代价 + 下一步的代价
                int new_dis = cur_dis + (grid[x][y] != i + 1);
                
                // 更新代价
                if (nx >= 0 && nx < m && ny >= 0 && ny < n && new_dis < dist[new_pos]) {
                    dist[new_pos] = new_dis;
                    q.emplace(new_dis, new_pos);
                }
            }
        }

        return dist[m * n - 1];
    }
};

// 0-1 BFS
using PII = pair<int, int>;

class Solution {
private:
    static constexpr int dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

public:
    int minCost(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<int> dist(m * n, INT_MAX);
        vector<int> seen(m * n, 0);
        dist[0] = 0;
        deque<int> q;
        q.push_back(0);
        
        while (!q.empty()) {
            auto cur_pos = q.front();
            q.pop_front();
            if (seen[cur_pos]) {
                continue;
            }
            seen[cur_pos] = 1;
            int x = cur_pos / n;
            int y = cur_pos % n;
            for (int i = 0; i < 4; ++i) {
                int nx = x + dirs[i][0];
                int ny = y + dirs[i][1];
                int new_pos = nx * n + ny;
                int new_dis = dist[cur_pos] + (grid[x][y] != i + 1);
                
                if (nx >= 0 && nx < m && ny >= 0 && ny < n && new_dis < dist[new_pos]) {
                    dist[new_pos] = new_dis;
                    if (grid[x][y] == i + 1) {
                        q.push_front(new_pos);
                    }
                    else {
                        q.push_back(new_pos);
                    }
                }
            }
        }

        return dist[m * n - 1];
    }
};

```

> 模板

```cpp
// 对称飞行器_阿里巴巴笔试题
using namespace std;

// 维护每个点的状态
struct Node {
    int x, y;   // 坐标 x, y
    int t;      // 飞行器剩余次数
    int s;      // 步数
};

int bfs(vector<string>& grid, vector<vector<int>>& visited, Node node) {
    int N = grid.size(), M = grid[0].size();
    vector<pair<int, int>> dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    queue<Node> que;
    que.emplace(node);
    
    while (!que.empty()) {
        Node n = que.front();
        que.pop();
        int x = n.x, y = n.y;
        // 到达终点
        if (grid[x][y] == 'E')  return n.s;
        
        for (int i = 0; i < 5; ++i) {
            Node temp;
            if (i == 4) {  // 使用飞行器
                if (n.t > 0) {
                    temp.x = N - 1 - x;
                    temp.y = M - 1 - y;
                    temp.s = n.s + 1;
                    temp.t = n.t - 1;
                }
            }
            else {
                temp.x = x + dirs[i].first;
                temp.y = y + dirs[i].second;
                temp.s = n.s + 1;
                temp.t = n.t;
            }

            if (temp.x >= 0 && temp.x < N && temp.y >= 0 && temp.y < M &&
                grid[temp.x][temp.y] != '#' && visited[temp.x][temp.y] == 0) {
                visited[temp.x][temp.y] = 1;
                que.emplace(temp);
            }
        }
    }
}
int main() {
    int N, M;
    cin >> N >> M;
    vector<string> grid(N);
    vector<vector<int>> visited(N, vector<int>(M, 0));
    for (int i = 0; i < N; ++i) cin >> grid[i];
    
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < M; ++j) {
            if (grid[i][j] == '#') {  // 找到点，然后bfs
                visited[i][j] = 1;
                Node node = {i, j, 5, 0};
                cout << bfs(grid, visited, node) << endl;
                return 0;
            }
        }
    }
    system("pause");
    return 0;
}
```



### 求深度

待总结岛屿问题！！！



### 求图中的某条符合条件的路径

例题：

1. [329. 矩阵中的最长递增路径](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/)

```cpp
// 329. 矩阵中的最长递增路径
class Solution {
public:
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        vector<vector<int>> memo(m, vector<int>(n, 0));
        int res = 0;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (memo[i][j] == 0)
                    res = max(res, dfs(matrix, m, n, i, j, memo));
            }
        }

        return res;
    }

private:
    const vector<pair<int, int>> dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    int dfs(vector<vector<int>>& matrix, int m, int n, int x, int y, vector<vector<int>>& memo) {
        if (memo[x][y] != 0) {
            return memo[x][y];
        }

        int res = 1;
        for (auto [dx, dy] : dirs) {
            int next_x = x + dx, next_y = y + dy;
            if (next_x >= 0 && next_x < m && next_y >= 0 && next_y < n && matrix[next_x][next_y] > matrix[x][y]) {
                res = max(res, dfs(matrix, m, n, next_x, next_y, memo) + 1);
            }
        }

        memo[x][y] = res;
        return res;
    }
};
```



### 求拓扑排序

每次从有向无环图 `graph` 中取出一个入度为0的节点添加到拓扑排序序列 `order` 中，然后删除该节点及所有以它为起点的边。重复这个步骤，直到图为空或图中不存在入度为0的节点：
* 图为空：图是有向无环图，此时 `order` 为该图的一个拓扑排序序列
* 图不为空且不存在入度为0的节点：图中一定有环

例题：

1. [剑指 Offer II 113. 课程顺序](https://leetcode-cn.com/problems/QA2IGt/)->BFS
2. [剑指 Offer II 115. 重建序列](https://leetcode.cn/problems/ur2n8P/)

```cpp
// 剑指 Offer II 113. 课程顺序
// n:节点数目 prerequisites：矩阵形式的邻接表
vector<int> findOrder(int n, vector<vector<int>>& prerequisites) {
    // 求有向图的拓扑排序

    unordered_map<int, vector<int>> graph;    // 用邻接表表示的图
    vector<int> inDegrees(n, 0);              // 记录入度的数组
    queue<int> que;                           // 存放入度为0的节点，用于BFS
    vector<int> order;                        // 存放结果

    // 建图
    for(const vector<int>& prerequisite : prerequisites) {
        graph[prerequisite[1]].push_back(prerequisite[0]);
        ++inDegrees[prerequisite[0]];
    }

    // 将入度为0的节点放入队列
    for(int i = 0; i < n; ++i) {
        if(inDegrees[i] == 0)   que.push(i);
    }

    // BFS
    while(!que.empty()) {
        int cur = que.front();
        que.pop();
        order.push_back(cur);

        for(const int& neighbor : graph[cur]) {
            --inDegrees[neighbor];
            if(inDegrees[neighbor] == 0)    que.push(neighbor);
        }
    }

    if(order.size() == n)  return order;
    return {};
}
```



### 并查集

并查集主要用于解决以下问题：
  1. 图中的子图数目是多少
  2. 最大的子图中有多少个节点

例题：

1. [剑指 Offer II 116. 省份数量](https://leetcode-cn.com/problems/bLyHh0/)->并查集
2. [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)



**初始化:**
![初始化](https://pic3.zhimg.com/80/v2-3153d1689405b4122b05d966b75b4e6a_720w.jpg)

**合并：**
![合并](https://pic4.zhimg.com/80/v2-f3c350c735a884d1b264c5e91c9edfdb_720w.jpg)

```cpp
// 统计子图数目
int findCircleNum(vector<vector<int>>& isConnected) {
    vector<int> fathers(isConnected.size());
    for(int i = 0; i < fathers.size(); ++i) {
        // 初始化：每个子图都与自己连通
        fathers[i] = i;
    }

    // 初始有count个子图，然后开始合并子图
    int count = isConnected.size();
    for(int i = 0; i < isConnected.size(); ++i) {
        for(int j = i + 1; j < isConnected[i].size(); ++j) {
            // 如果两个子图连通，并且可以合并（两个子图可能已经连通）
            if(isConnected[i][j] == 1 && union(fathers, i, j)) {
                --count;
                
            }
        }
    }

    return count;
}

int findFather(vector<int>& fathers, int i) {
    if(fathers[i] != i) {
        // 递归找根节点
        fathers[i] = findFather(fathers, fathers[i]);
    }

    return fathers[i];
}

bool union(vector<int>& fathers, int i, int j) {
    int fatherI = findFather(fathers, i);
    int fatherJ = findFather(fathers, j);

    // 合并两个子图
    if(fatherI != fatherJ) {
        fathers[fatherI] = fatherJ;
        return true;
    }

    // 两个子图本来就连通
    return false;
}
```



#### 并查集类的模板（必背）

```c++
class UnionFind {
public:
    UnionFind(vector<vector<char>>& grid) {  //二维数组需要将坐标转换为一维坐标
        count = 0;
        int m = grid.size();
        int n = grid[0].size();
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == '1') {
                    parent.push_back(i * n + j);
                    ++count;
                }
                else {
                    parent.push_back(-1);
                }
                rank.push_back(0);
            }
        }
    }

    int find(int i) {
        if (parent[i] != i) {
            parent[i] = find(parent[i]);
        }
        return parent[i];
    }

    void Union(int x, int y) {
        int rootx = find(x);
        int rooty = find(y);
        if (rootx != rooty) {
            if (rank[rootx] < rank[rooty]) { // 层数小的接到层数大的节点（减小整体层数）
                parent[rootx] = rooty;
            }
            else if(rank[rooty] < rank[rootx]) {
                parent[rooty] = rootx;
            }
            else {
                parent[rootx] = rooty;
                ++rank[rooty];
            }
            --count;
        }
    }

    int getCount() const {
        return count;
    }

private:
    vector<int> parent; // parent[i]表示第i个元素所指向的父节点
    vector<int> rank;	// rank[i]表示以i为根的集合所表示的树的层数
    int count;          // 连通的子图数
};

// 200. 岛屿数量
// 使用起来也比较简单
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int nr = grid.size();
        if (!nr) return 0;
        int nc = grid[0].size();

        UnionFind uf(grid);  //建立并查集
        int num_islands = 0;
        for (int r = 0; r < nr; ++r) {
            for (int c = 0; c < nc; ++c) {
                if (grid[r][c] == '1') {  //不断连通子图
                    grid[r][c] = '0';
                    if (r - 1 >= 0 && grid[r-1][c] == '1') uf.Union(r * nc + c, (r-1) * nc + c);
                    if (r + 1 < nr && grid[r+1][c] == '1') uf.Union(r * nc + c, (r+1) * nc + c);
                    if (c - 1 >= 0 && grid[r][c-1] == '1') uf.Union(r * nc + c, r * nc + c - 1);
                    if (c + 1 < nc && grid[r][c+1] == '1') uf.Union(r * nc + c, r * nc + c + 1);
                }
            }
        }

        return uf.getCount();  //获取连通子图个数
    }
};

```



#### 并查集查找最大连通子图的节点数

`Union` 结束后，遍历所有节点，记录根节点的连通数。

例题：

1. [952. 按公因数计算最大组件大小](https://leetcode.cn/problems/largest-component-size-by-common-factor/)

```c++
class UnionFind {
public:
    UnionFind(int n) : parent(n, 0), rank(n, 0) {
        for (int i = 0; i < n; ++i) {
            parent[i] = i;
        }
    }

    int Find(int x) {
        if (parent[x] != x) {
            parent[x] = Find(parent[x]);
        }
        return parent[x];
    }

    void Union(int x, int y) {
        int rootx = Find(x);
        int rooty = Find(y);
        if (rootx != rooty) {  // 层数少的接到层数多的节点上
            if (rank[rootx] > rank[rooty]) {
                parent[rooty] = rootx;
            }
            else if (rank[rootx] < rank[rooty]) {
                parent[rootx] = rooty;
            }
            else {
                parent[rooty] = rootx;
                ++rank[rootx];
            }
        }
    }

private:
    vector<int> parent, rank;
};

class Solution {
public:
    int largestComponentSize(vector<int>& nums) {
        int maxNum = 0;
        for (int& num : nums)   maxNum = max(maxNum, num);
        UnionFind myUnion(maxNum + 1);

        for (int& num : nums) {
            for (int i = 2; i * i <= num; ++i) {
                if (num % i == 0) {
                    myUnion.Union(num, i);
                    myUnion.Union(num, num / i);
                }
            }
        }

        vector<int> cnt(maxNum + 1, 0);
        int res = 0;
        for (int& num : nums) {
            auto temp = ++cnt[myUnion.Find(num)];
            res = max(res, temp);
        }

        return res;
    }
};
```





## 模拟加减乘除

### 不用除号的除法

例题：[29. 两数相除](https://leetcode-cn.com/problems/divide-two-integers/)

```c++
int divide(int dividend, int divisor) {
    if(dividend == INT_MIN) {
        if(divisor == 1)
            return INT_MIN;
        else if(divisor == -1)
            return INT_MAX;
    }
    if(divisor == INT_MIN) {
        if(dividend == INT_MIN)
            return 1;
        else
            return 0;
    }

    // 转换为负数计算（负数范围更大）
    bool flag = false;
    if(dividend > 0) {
        dividend = -dividend;
        flag = !flag;
    }
    if(divisor > 0) {
        divisor = -divisor;
        flag = !flag;
    }

    int result = 0;
    vector<int> candicates = {divisor};
    while(dividend - candicates.back() <= candicates.back()) {
        candicates.emplace_back(candicates.back() + candicates.back());
    }

    for(int i = candicates.size() - 1; i >= 0; --i) {
        if(dividend <= candicates[i]) {
            dividend -= candicates[i];
            result += (1 << i);
        }
    }

    return flag? -result : result;
}
```

### 快速幂

例题：[50. Pow(x, n)](https://leetcode.cn/problems/powx-n/)

- 递归版

把递归的树状图画出来分析时间复杂度

```c++
double myPow(double x, int n) {
    if(n == 0)  return 1.0;
    else if((n & 1) == 0) {
        return myPow(x * x, n / 2);
    }
    else {
        return (n > 0 ? x : 1.0 / x) * myPow(x * x, n / 2);
    }
}
```

- 迭代版

![HQM7S.png](https://s1.328888.xyz/2022/05/10/HQM7S.png)

```c++
double myPow(double x, int n) {
    if(x == 0)  return x;
    int64_t power = n;

    if(n < 0) { // 如果n < 0，求1/x的-n次方
        power *= -1;
        x = 1 / x;
    }

    double result = 1, weight = x;
    while(power != 0) {
        if((power & 1) == 1)
            result *= weight;
        weight *= weight;
        power >>= 1;
    }

    return result;
}
```



### 平方根

例题：

1. [69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/)



- 二分法

从`[0, x]`开始二分查找，注意的是，当`mid*mid <= x`时，mid既有可能是解，也有可能不是。

```c++
int mySqrt(int x) {
    if(x == 1)  return 1;
    if(x == 0)  return 0;
    int left = 0, right = x, result = -1;
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if((long long) mid * mid <= x) {
            result = mid;
            left = mid + 1;
        }
        else {
            right = mid - 1;
        }
    }

    return result;
}
```

- 牛顿迭代法（求精确的需要使用该方法）

由于寻找方程零点，就是从起始点开始，一直作斜率为
$$
f'(x_i) = 2x_i
$$
的切线，然后求直线与x轴的交点，为下一个起始点。

```c++
int mySqrt(int x) {
    if (x == 0) {
        return 0;
    }

    double C = x, x0 = x;
    while (true) {
        double xi = 0.5 * (x0 + C / x0);
        if (fabs(x0 - xi) < 1e-7) {
            break;
        }
        x0 = xi;
    }
    return int(x0);
}
```



### 分数加减乘除

例题：

1. [592. 分数加减运算](https://leetcode.cn/problems/fraction-addition-and-subtraction/)（将分数拆分，相加即可）

```cpp
class Solution {
public:
    string fractionAddition(string expression) {
        long long denominator = 0, numerator = 1; // 分子，分母
        int index = 0, n = expression.size();
        while (index < n) {
            // 读取分子
            long long denominator1 = 0, sign = 1;
            if (expression[index] == '-' || expression[index] == '+') {
                sign = expression[index] == '-' ? -1 : 1;
                index++;
            }
            while (index < n && isdigit(expression[index])) {
                denominator1 = denominator1 * 10 + expression[index] - '0';
                index++;
            }
            denominator1 = sign * denominator1;
            index++;

            // 读取分母
            long long numerator1 = 0;
            while (index < n && isdigit(expression[index])) {
                numerator1 = numerator1 * 10 + expression[index] - '0';
                index++;
            }

            denominator = denominator * numerator1 + denominator1 * numerator;
            numerator *= numerator1;
        }
        if (denominator == 0) {
            return "0/1";
        }
        long long g = gcd(abs(denominator), numerator); // 获取最大公约数
        return to_string(denominator / g) + "/" + to_string(numerator / g);
    }
};
```



## 位运算

位运算都比较简单，主要是记住以下公式

1. 将一个数的最后一个1变为0：$$n \& (n - 1)$$
2. 获取一个数最后的1：$$n \& (-n)$$
2. 两个数 x 和 y，x 和 y 中二进制1的个数的和，等于 $x\&y$ 和 $x|y$ 中二进制1的个数的和：$bitCount(x \& y) + bitCount(x | y) = bitCount(x) + bitCount(y)$

以此可以在 $$O(log(n))$$ 解决以下题目：

1. [剑指 Offer 15. 二进制中1的个数](https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)
2. [231. 2 的幂](https://leetcode.cn/problems/power-of-two/)（看一个数里面是不是只有一个1）
3. [输入两个数m、n，计算要改变几位二进制位才能由m得到n](https://blog.csdn.net/hansionz/article/details/82254970)（两个数取异或，然后统计1的个数）
4. 



### 找出数组中只出现一次的数字

例题：

1. [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)（只有一个数字不同的话，直接异或）
2. [剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)（有两个数字不同，分成两组异或，那么分组的依据是什么呢？就是异或所有数的结果就是两个数字不同的地方，以此为依据分组）
3. [剑指 Offer 56 - II. 数组中数字出现的次数 II](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/)（只有一个数字不同，但是其他数字出现了三次，所以不能用异或了，可以统计所有数字的位，如果一个位的计数，为3的倍数，说明只出现一次的数字这个位不是1）
3. [6127. 优质数对的数目](https://leetcode.cn/problems/number-of-excellent-pairs/)（利用公式3，退化为二分查找）



```c++
// 剑指 Offer 56 - I. 数组中数字出现的次数
vector<int> singleNumbers(vector<int>& nums) {
    // 表示两个只出现一次的数字中不同的位
    int cnt = 0;
    for(const int& num : nums) {
        cnt ^= num;
    }

    int num1 = 0, num2 = 0;
    int indexBit = cnt & (-cnt);

    for(const int& num : nums) {
        if((num & indexBit) == 0) {
            num1 ^= num;
        }
        else {
            num2 ^= num;
        }
    }

    return {num1, num2};
}

// 剑指 Offer 56 - II. 数组中数字出现的次数 II
int singleNumber(vector<int>& nums) {
    vector<int> bitSum(32, 0);
    int res = 0;
    for (int& num : nums) {
        for (int i = 31; i >= 0; --i) {
            if ((num >> i) & 1 == 1) {
                ++bitSum[i];
            }
        }
    }

    for (int i = 31; i >= 0; --i) {
        res <<= 1;
        res += bitSum[i] % 3;
    }

    return res;
}
```









## 字符串相关

### 字符串翻转问题

例题：

1. [剑指 Offer 58 - I. 翻转单词顺序](https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/)（两个思路：stirngstream和从后往前遍历）



### 字符串删除问题

例题：

1. [844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)（两个思路：（1）在原地修改字符串，方法与在数组中原地删除元素相同（2）从后往前遍历，基于可以删除的字符个数）

<img src="https://assets.leetcode-cn.com/solution-static/844/1.gif" alt="fig1" style="zoom: 50%;" />

```c++
bool backspaceCompare(string s, string t) {
    int i = s.size() - 1, skipS = 0;
    int j = t.size() - 1, skipT = 0;

    while (i >= 0 || j >= 0) {
        while (i >= 0) {
            if (s[i] == '#') {
                --i;
                ++skipS;
            }
            else if (skipS > 0) {
                --i;
                --skipS;
            }
            else {
                break;
            }
        }
        while (j >= 0) {
            if (t[j] == '#') {
                --j;
                ++skipT;
            }
            else if (skipT > 0) {
                --j;
                --skipT;
            }
            else {
                break;
            }
        }
        if (i >= 0 && j >= 0) {
            if (s[i] != t[j])   return false;
        }
        else {
            if (i >= 0 || j >= 0)   return false;
        }

        --i;
        --j;
    }

    return true;
}
```



### 字符串匹配问题（KMP/DP）

#### KMP 算法

KMP的经典思想就是：**当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。**

![KMP精讲2](https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B22.gif)

KMP 的核心就是前缀表：**记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**

> 核心步骤

1. 构造 `next` 数组（前缀表）

   <img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B23.gif" alt="KMP精讲3"  />

   - 定义两个指针 i 和 j，j 指向前缀末尾位置，i 指向后缀末尾位置。

   - s[i] 与 s[j+1]不相同，也就是遇到 前后缀末尾不相同的情况，就要向前回退

     ```cpp
     void getNext(int* next, const string& s) {
         int j = -1;
         next[0] = j;
         for(int i = 1; i < s.size(); i++) { // 注意i从1开始
             while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
                 j = next[j]; // 向前回退
             }
             if (s[i] == s[j + 1]) { // 找到相同的前后缀
                 j++;
             }
             next[i] = j; // 将j（前缀的长度）赋给next[i]
         }
     }
     ```

     

2. 使用 next 数组（前缀表）进行匹配

   ```c++
   // Strstr() 的 KMP 实现
   // 可以将 haystack 视为文本串，needle 为模式串
   int strStr(string haystack, string needle) {
       // kmp 大法
       if (needle.size() == 0) return 0;
       if (haystack.size() < needle.size())    return -1;
   
       vector<int> next = getNext(needle);
       int j = -1;
       for (int i = 0; i < haystack.size(); ++i) {
           while (j >= 0 && haystack[i] != needle[j + 1]) {  // 前后缀不相同
               j = next[j];  // 回退
           }
           if (haystack[i] == needle[j + 1]) {  // 匹配的话，i和j同时向后移动
               ++j;
           }
           if (j + 1 == needle.size()) {  // 匹配完成
               return (i - j);
           }
       }
   
       return -1;
   }
   ```

   

### 字符串的循环问题

字符串的循环队列可以暴力地用 `substr` 拼接，也可以将两个长度为 n 的字符串 s ，拼接起来，去遍历长度为 n 的子串。

例题：

1. [899. 有序队列](https://leetcode.cn/problems/orderly-queue/)





## 动态规划



### 背包问题

> 关键词

1. 找出数组中元素的和sum不大于 target 时的最大和
2. **组合问题公式**：`dp[i] += dp[i-num]`
2. **True、False问题公式**：`dp[i] = dp[i] or dp[i-num]`
2. **最大最小问题公式**：`dp[i] = min(dp[i], dp[i-num]+1)` 或者 `dp[i] = max(dp[i], dp[i-num]+1)`



#### 0-1背包

**把具体场景抽象为背包问题，剩下的就是套板子了。**

> 例题

1. [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum)（与[698. 划分为k个相等的子集](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets)对比）
2. [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii)
3. [494. 目标和](https://leetcode.cn/problems/target-sum)
4. [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes)（**两个维度的cost**，之前只有一个维度的cost—背包容量，有点hard的感觉了）



> 适用问题

一个物品只有两种状态：放 or 不放。但是放这个物品是有代价的，代价不能超过 k。

由此建立 dp数组：$dp[i][j]$**表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少**。状态转移方程推导如下：

1. 不放物品i：由 $dp[i - 1][j]$ 推出，即背包容量为j，里面不放物品i的最大价值。
2. 放物品i：由 $dp[i - 1][j - weight[i]]$ 推出，背包容量为 $j - weight[i]$ 的时候不放物品i的最大价值，当然要**保证背包容量足够**
3. 状态转移方程：$dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])$



> 典型场景

背包最大重量为4。物品为：

|       | 重量 | 价值 |
| ----- | ---- | ---- |
| 物品0 | 1    | 15   |
| 物品1 | 3    | 20   |
| 物品2 | 4    | 30   |

问背包能背的物品最大价值是多少？



> 解题模板

- 二维数组

```cpp
void test_2_wei_bag_problem1() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagweight = 4;

    // 二维数组
    vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));

    // 初始化
    // 需要想清楚第一行和第一列的初始状态到底是什么
    for (int j = weight[0]; j <= bagweight; j++) {
        dp[0][j] = value[0];
    }

    // weight数组的大小 就是物品个数
    for(int i = 1; i < weight.size(); i++) {   // 遍历物品
        for(int j = 0; j <= bagweight; j++) {  // 遍历背包容量
            if (j < weight[i]) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
        }
    }

    cout << dp[weight.size() - 1][bagweight] << endl;
}
```



- 一维数组（滚动数组优化）

状态转移方程中，$dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])$，当前位置的值只与左边和上面的值有关，所以可以用一维数组优化，但是注意 j 要从右往左遍历，不然会覆盖还没计算的上一层的值（**体现到值上就是一个物品被放入多次，违背了0-1背包的设定**）。

由此得到新的状态转移方程：$dp[j] = max(dp[j], dp[j - weight[i]] + value[i])$

```cpp
void test_1_wei_bag_problem() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;

    // 初始化
    vector<int> dp(bagWeight + 1, 0);
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    cout << dp[bagWeight] << endl;
}
```









#### 完全背包

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

**完全背包和0-1背包问题唯一不同的地方就是，每种物品有无限件**。

> 例题

1. [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-2)（排列数）
2. [322. 零钱兑换](https://leetcode.cn/problems/coin-change)（最小组合数）
3. [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)（最小排列/组合数）
3. [139. 单词拆分](https://leetcode.cn/problems/word-break/)（字符串作为物品）





> 解题模板

**在完全背包中，对于一维dp数组来说，两个for循环嵌套顺序无所谓**，因为dp[j] 是根据 下标j之前所对应的dp[j]计算出来的。 只要保证下标j之前的dp[j]都是经过计算的就可以了。

```cpp
// 先遍历物品，在遍历背包
void test_CompletePack() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;
    vector<int> dp(bagWeight + 1, 0);
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = weight[i]; j <= bagWeight; j++) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    cout << dp[bagWeight] << endl;
}
```



#### 多重背包

多重背包就是背包里的物品**有数量限制**，不同于0-1背包中的物品只有一件，这里可以有多件。

> 例题



> 解题思路

1. 思路一：直接将每件物品摊开，就变成一个0-1背包了
2. 思路二：以0-1背包的形式进行遍历，在最内层循环中加入遍历数量的循环



> 解题模板

- **摊开物品**

  ```cpp
  void test_multi_pack() {
      vector<int> weight = {1, 3, 4};
      vector<int> value = {15, 20, 30};
      vector<int> nums = {2, 3, 2};
      int bagWeight = 10;
      for (int i = 0; i < nums.size(); i++) {
          while (nums[i] > 1) { // nums[i]保留到1，把其他物品都展开
              weight.push_back(weight[i]);
              value.push_back(value[i]);
              nums[i]--;
          }
      }
  
      vector<int> dp(bagWeight + 1, 0);
      for(int i = 0; i < weight.size(); i++) { // 遍历物品
          for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
              dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
          }
          for (int j = 0; j <= bagWeight; j++) {
              cout << dp[j] << " ";
          }
          cout << endl;
      }
      cout << dp[bagWeight] << endl;
  
  }
  ```

- **循环遍历数量**

  ```cpp
  void test_multi_pack() {
      vector<int> weight = {1, 3, 4};
      vector<int> value = {15, 20, 30};
      vector<int> nums = {2, 3, 2};
      int bagWeight = 10;
      vector<int> dp(bagWeight + 1, 0);
  
  
      for(int i = 0; i < weight.size(); i++) { // 遍历物品
          for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
              // 以上为01背包，然后加一个遍历个数
              for (int k = 1; k <= nums[i] && (j - k * weight[i]) >= 0; k++) { // 遍历个数
                  dp[j] = max(dp[j], dp[j - k * weight[i]] + k * value[i]);
              }
          }
          // 打印一下dp数组
          for (int j = 0; j <= bagWeight; j++) {
              cout << dp[j] << " ";
          }
          cout << endl;
      }
      cout << dp[bagWeight] << endl;
  }
  ```





### 排列组合问题

排列组合问题是基于背包问题建立的，所以要先判断是什么类型的背包（元素能不能重复使用？）

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

dp 数组的含义不同：

然后就是状态转移方程的不同（与最大最小值不同）：不考虑 $nums[i]$ 的情况下，填满容量为 $j - nums[i]$ 的背包，有 $dp[j - nums[i]]$ 种方法。

> 注意点

1. 排列组合问题的状态转移方程都是一致的：$dp[j] = dp[j]+dp[j - nums[i]]$
1. 区别只有遍历内外层循环不同。先遍历物品的话，物品永远是按序放的。



> 例题

- **排列问题**
  1. [377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv)
- **组合问题**
  1. [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-2)
  1. 







### 类爬楼梯问题

#### 爬楼梯

爬上当前楼梯的方法，由之前爬过楼梯的方法决定



#### 圆环回到原点（字节高频手撕题）

圆环上有10个点，编号为0~9。从0点出发，每次可以逆时针和顺时针走一步，问走n步回到0点共有多少种走法。

```text
输入: 2
输出: 2
解释：有2种方案。分别是0->1->0和0->9->0
```

递推公式：

1. 设 $dp[i][j]$ 为从 0 点出发走 i 步到 j 点的方案数，一个点的方法数只与它上一点和下一点的方法数有关。
2. $dp[i][j] = dp[i - 1][(j - 1 + length)\%length] + dp[i - 1][(j + 1)\%length]$，公式之所以取余是因为 j-1 或 j+1 可能会超过圆环 0~9 的范围

**该题型的其他变式：**

1. 0-12共13个数构成一个环，从0出发，每次走1步，走n步回到0共有多少种走法（[2020.09 字节跳动-广告-后端](https://www.nowcoder.com/discuss/510719)）
2. 0-8组成一个圆环，从0出发，每次可以逆时针和顺时针走，走n步能回到0有多少种情况（[2020.09 字节跳动-people-后端](https://www.nowcoder.com/discuss/512998)）
3. 0~9的环，从0出发，N步后能否走回0。（[2020.07 字节跳动-电商-后端](https://www.nowcoder.com/discuss/499381)）
4. 圆环回原点问题 （[2020.08 字节跳动-飞书-后端](https://www.nowcoder.com/discuss/468824)）



```cpp
// n 个点，走 k 步，回到原点的方法数
int backToOrigin(int n, int k) {
    vector<vector<int>> dp(n + 1, vector<int>(10, 0));
    dp[0][0] = 1;
    
    for (int i = 1; i <= n; ++i) {  // 遍历步数
        for (int j = 0; j < k; ++j)  // 更新到每个点的方法
            dp[i][j] = dp[i - 1][(j - 1 + k) % k] + dp[i - 1][(j + 1) % k];
    }
    
    return dp[n][0];
}
```



### 子序列及子串问题

#### 子串问题



##### 回文子串

子串可以通过删除数组中一些元素来形成，所以用 $dp[i][j]$ 表示 **在子串 `s[i..j]` 中，符合条件的最长子序列长度**，由此可以推导出递推公式（通过枚举 $dp[i + 1][j]$ 和 $dp[i][j - 1]$ 来枚举删除删除的情况）：

例题：

1. [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)





#### 子序列问题

一旦涉及到子序列和最值，那几乎可以肯定，**考察的是动态规划技巧，时间复杂度一般都是 O(n^2)**

子序列可以通过删除数组中一些元素来形成，所以用 $dp[i][j]$ 表示 **在子串 `s[i..j]` 中，符合条件的最长子序列长度**，由此可以推导出递推公式（通过枚举 $dp[i + 1][j]$ 和 $dp[i][j - 1]$ 来枚举删除删除的情况）：

```cpp
if (s[i] == s[j])  // 符合条件，那么看下删掉这两个字符的最长子序列
    // 它俩一定在最长回文子序列中
    dp[i][j] = dp[i + 1][j - 1] + 2;
else  // 不符合条件，看下删哪个
    // s[i+1..j] 和 s[i..j-1] 谁的回文子序列更长？
    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
```

> 例题

1. [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)
2. [最长递增子序列—牛客网 (nowcoder.com)](https://www.nowcoder.com/questionTerminal/30fb9b3cab9742ecae9acda1c75bf927)（dp + 二分）
3. [115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)（基本思路就是看删/不删）
3. [72. 编辑距离](https://leetcode.cn/problems/edit-distance)
3. [873. 最长的斐波那契子序列的长度](https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/)（确定第三个数，双指针找前两个）



##### 回文子序列

对于回文子序列还可以考虑：将字符串反转，求最长公共子序列

> 例题

1. [516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)（s 与 s.reverse() 的最长公共子序列即为其最长回文子序列）
2. [1312. 让字符串成为回文串的最少插入次数](https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/)（同上）



##### 最长递增子序列的dp+二分

```cpp
// 最长递增子序列
// O(n²)，就正常 dp 遍历
// O(nlog(n))，使用 ends 数组记录长度为i+1的递增子序列的最小的结束元素。
// 然后 二分查找 更新 dp 的状态
vector<int> helper(vector<int>& nums) {
    int n = nums.size();
    vector<int> dp(n, 1);
    vector<int> ends(n, 0); // ends[i]表示长度为 i + 1 的递增子序列的最小结束元素
    ends[0] = nums[0];
    int right = 0;  // ends 的有效范围 [0, right]
    int l = 0, r = 0;
    int maxLen = 1;  // 最长递增子序列的长度
    int maxIdx = 0;  // 最长递增子序列结束元素的索引
    for(int i = 0; i < n; ++i) {
        l = 0;
        r = right;
        // 查找 nums[i] 在 ends 有效范围上的插入位置
        // 如果比 ends 所有元素都大，则扩大右边界
        while(l <= r) {
            int mid = (l + r) >> 1;
            if(nums[i] > ends[mid]) {
                l = mid + 1;
            }
            else {
                r = mid - 1;
            }
        }
        // 如果比 ends 所有元素都大，此时 l = right + 1
        right = max(right, l);
        ends[l] = nums[i];  // 更新结束元素
        dp[i] = l + 1;  // 以 nums[i] 为结束元素的最长递增子序列长度
        // 更新最大长度，由于题目有字典序最小的要求，=是必须的
        if(dp[i] >= maxLen) {
            maxLen = dp[i];
            maxIdx = i;
        }
    }
    
    vector<int> res(maxLen);
    for(int i = maxIdx; i >= 0; --i) {
        if(dp[i] == maxLen) {
            res[--maxLen] = nums[i];
        }
    }
    
    return res;
}
```

##### 符合递推关系的子序列

这类题型一般会给出递推关系：$nums[k]=f(nums[i], nums[j])$

基本思想是固定一个/两个，然后找其他的

> 例题

1. [873. 最长的斐波那契子序列的长度](https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/)（因为$f(n)=f(n-1)+f(n-2)$，所以确定$f(n)$就可以确定其他两个）
2. [1027. 最长等差数列](https://leetcode.cn/problems/longest-arithmetic-subsequence/)（$f(n-2)=2*f(n-1)-f(n)$，需要确定 $f(n)$ 和 $f(n-1)$ 才能确定另外一个）



> 模板

重点是搞清楚固定哪个数

```c++
// 1027. 最长等差数列
int longestArithSeqLength(vector<int>& nums) {
    int n = nums.size();
    vector<vector<int>> dp(n, vector<int>(n, 0));
    unordered_map<int, int> dict;  // num to index
    int res = 0;

    // 先枚举 a2, a3
    for (int j = 0; j < n; ++j) {
        for (int k = j + 1; k < n; ++k) {
            int target = 2 * nums[j] - nums[k];  // 计算 a1
            if (dict.count(target) != 0) {
                dp[j][k] = dp[dict[target]][j] + 1;
                res = max(dp[j][k], res);
            }
        }
        dict[nums[j]] = j;
    }

    return res + 2;
}
```



##### 编辑距离

编辑距离本质上是看删哪个，添加哪个，替换哪个的问题，状态转移方程比较简单，这里简单记录一下变式：

例题：

1. [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)
2. [NC35 编辑距离(二)](https://www.nowcoder.com/practice/05fed41805ae4394ab6607d0d745c8e4?tpId=196&tqId=37134&ru=/exam/oj)（带操作代价的编辑距离）
3. [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)（额外要求：输出最长公共子序列）

```cpp
int minEditCost(string str1, string str2, int ic, int dc, int rc) {
    // write code here
    int m = str1.size(), n = str2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    for (int i = 1; i <= m; ++i)    dp[i][0] = i * dc;
    for (int j = 1; j <= n; ++j)    dp[0][j] = j * ic;

    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (str1[i - 1] == str2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            }
            else {
                dp[i][j] = min({dp[i - 1][j] + dc, dp[i][j - 1] + ic, dp[i - 1][j - 1] + rc});
            }
        }
    }

    return dp[m][n];
}
```







### 图的动态规划

基本都是 hard，笔试随缘吧。。。 

1. [741. 摘樱桃](https://leetcode.cn/problems/cherry-pickup/)







## 回溯

回溯法，一般可以解决如下几种问题（**重点是要得出具体解法是什么，而不是多少种解法**）：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等



### 排列/组合/子集问题

无论是排列、组合还是子集问题，简单说无非就是从序列 `nums` 中以给定规则取若干元素，主要有以下几种变体：

2. **元素无重不可复选**，即 `nums` 中的元素都是唯一的，每个元素最多只能被使用一次，这也是最基本的形式。
2. **元素可重不可复选**，即 `nums` 中的元素可以存在重复，每个元素最多只能被使用一次。
2. **元素无重可复选**，即 `nums` 中的元素都是唯一的，每个元素可以被使用若干次。



#### 元素无重不可重复选

**通过保证元素之间的相对顺序不变来防止出现重复的子集**。即遍历的时候通过一个 `startIndex` 控制顺序

1. [77. 组合](https://leetcode.cn/problems/combinations/)（梦开始的地方）
2. [216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)
3. [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)
4. [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning)

> 关键代码

```c++
// 无重组合的回溯算法框架
void backtrack(int[] nums, int start) {
    for (int i = start; i < nums.length; i++) {
        // ...
        // 递归遍历下一层回溯树，注意参数
        backtrack(nums, i + 1);
        // ...
    }
}
```



#### 元素可重不可复选

这类问题跟子集是等价的，关键是要对 ` nums` 进行排序，如果同一数层的元素重复，则不应继续循环。

1. [90. 子集 II](https://leetcode.cn/problems/subsets-ii/)
2. [40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)

> 关键代码

```c++
void backtrack(int[] nums, int start) {
    for (int i = start; i < nums.length; i++) {
        // 剪枝逻辑，值相同的相邻树枝，只遍历第一条
        if (i > start && nums[i] == nums[i - 1]) {
            continue;
        }
        // ...
        // 递归遍历下一层回溯树，注意参数
        backtrack(nums, i + 1);
        // ...
    }
}
```





#### 元素无重可重复选

1. [39. 组合总和](https://leetcode.cn/problems/combination-sum/)（元素可以重复使用）

> 关键代码

```c++
// 可重组合的回溯算法框架
void backtrack(int[] nums, int start) {
    for (int i = start; i < nums.length; i++) {
        // ...
        // 递归遍历下一层回溯树，注意参数
        backtrack(nums, i);
        // ...
    }
}
```



### 子序列问题

主要考虑的就是子序列的去重，用一下哈希就好了

例题：

1. [491. 递增子序列](https://leetcode.cn/problems/increasing-subsequences/)

```c++
// 491. 递增子序列
class Solution {
public:
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        backtracking(nums, 0);

        return res;
    }

private:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(vector<int>& nums, int start) {
        if (path.size() >= 2) {
            res.emplace_back(path);
        }

        // 核心就是去重
        unordered_set<int> dict;
        for (int i = start; i < nums.size(); ++i) {
            if (dict.count(nums[i]) != 0)   continue;
            if (path.empty() || nums[i] >= path.back()) {
                path.emplace_back(nums[i]);
                backtracking(nums, i + 1);
                path.pop_back();
            }
            dict.insert(nums[i]);
        }
    }
};
```





### 分组问题（确定分多少组）

**共同特点**：将数组中的元素分为 k 组（可以不按照顺序），求满足特定条件的数量。

**思路**：将数组中的元素看作球，然后建立 k 个桶，回溯的过程就是将球放到桶里的过程。（回溯中还需要考虑剪枝的情况）

**例题**：

1. [5289. 公平分发饼干](https://leetcode.cn/problems/fair-distribution-of-cookies/)
2. [698. 划分为k个相等的子集](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)
3. [473. 火柴拼正方形](https://leetcode.cn/problems/matchsticks-to-square/)（正方形的四条边抽象成四个桶，桶里面元素和必须相等）

```c++
// 698. 划分为k个相等的子集
class Solution {
public:
    bool canPartitionKSubsets(vector<int>& nums, int k) {
        int sum = 0;
        for(const int& num : nums) {
            sum += num;
        }
        if(sum % k != 0)    return false;
        target = sum / k;
        // 排序，将容易把桶占满的元素放在前面
        sort(nums.begin(), nums.end(), greater<int>());
        vector<int> buckets(k, 0);
        return backtracking(nums, buckets, 0);
    }

private:
    int target;
    bool backtracking(vector<int>& nums, vector<int>& buckets, int start) {
        if(start >= nums.size()) {
            for(int i = 1; i < buckets.size(); ++i) {
                if(buckets[i] != buckets[i - 1])
                    return false;
            }
            return true;
        }

        // 将该元素，分别放入每个桶中
        for(int i = 0; i < buckets.size(); ++i) {
            // 超出当前桶的剩余大小，直接跳过
            if(buckets[i] + nums[start] > target) continue;
            // 前后桶元素和相同
            if(i > 0 && buckets[i] == buckets[i - 1]) continue;
            buckets[i] += nums[start];
            if(backtracking(nums, buckets, start + 1))
                return true;
            buckets[i] -= nums[start];
        }

        return false;
    }
};
```



### 字符串的回溯

主要分两步：字符串的分割，字符串合法性的判断。

例题：

1. [93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses)（蔚来二面，虾皮笔试）
2. [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning)







## 分治

分治的题目做的比较少，这里先按照题型总结：

### 分解为左右两个子问题

递归求解左右两边的结果，然后根据规则求解最终结果

例题：

1. [241. 为运算表达式设计优先级](https://leetcode.cn/problems/different-ways-to-add-parentheses/)

```cpp
// 241. 为运算表达式设计优先级
class Solution {
    unordered_map<string, vector<int>> memo;  // 备忘录，避免计算重复的表达式
public:
    vector<int> diffWaysToCompute(string expression) {
        if (memo.count(expression) != 0) {  // 表达式已经计算过
            return memo[expression];
        }
        vector<int> res;
        for (int i = 0; i < expression.size(); ++i) {
            char& c = expression[i];
            if (c == '+' || c == '-' || c == '*') {
                string expLeft = expression.substr(0, i), expRight = expression.substr(i + 1);
                vector<int> left = diffWaysToCompute(expLeft), right = diffWaysToCompute(expRight);
                for (int& l : left) {  // 遍历运算符左边和右边的所有结果
                    for (int& r : right) {
                        int temp;
                        if (c == '+')   temp = l + r;
                        if (c == '-')   temp = l - r;
                        if (c == '*')   temp = l * r;
                        res.emplace_back(temp);
                    }
                }
            }
        }

        if (res.empty()) {  // 如果表达式中没有运算符
            res.emplace_back(stoi(expression));
        }
        memo[expression] = res;   // 记录一下表达式的结果

        return res;
    }
};
```



## 排列组合问题

排列组合问题还是比较常考的，这里记录一下题型。



### 排列问题

例题：

1. [556. 下一个更大元素 III](https://leetcode.cn/problems/next-greater-element-iii/)，[31. 下一个排列](https://leetcode.cn/problems/next-permutation/)（都是一类题型，就是从后往前找第一个【数字比后一位小的位置】，然后重新排列后面的数）



## 计算奇奇怪怪的数



### 最大公因数/最大公约数（gcd）

1. 库函数 `int std::gcd(int a, int b)` ，需要包含头文件 `#include <algorithm>`

2. **辗转相除法**：不断将 $a\%b$ 作为除数，直到 b 为0，返回 a

   ```cpp
   int myGcd(int a, int b) {
       // 都转换为整数
       if (a < 0) a = -a;
       if (b < 0) b = -b;
       if (a < b) swap(a, b);
       if (b == 0) return a;
   
       // a > b
       // 24 15
       // 24 / 15 = 1 ... 9
       // 15 / 9  = 1 ... 6
       // 9  / 6  = 1 ... 3
       // 6  / 3  = 2 ... 0
       
       while (b) {
           int temp = b;
           b = a % b;
           a = temp;
       }
   
       return a;
   }
   ```

   





### 质数/素数

给定整数 `n` ，返回 *所有小于非负整数 `n` 的质数的数量* 。

#### 思路

1. 从 2 开始搜索，判断每个遍历的数是否质数。
2. **线性筛法**：空间换时间，建立一个质数列表，因为一个数 x 是质数的话，后面的 x, 2x, 3x, ...... 一定不是质数，但是 2x, 3x 前面一定已经遍历过了，所以可以从 x*x 开始遍历到 n

因为判断一个数字是否是素数的时间成本较高，所以我们不要一个个判断每个数字是否是素数，而是用排除法，把所有非素数都排除，剩下的就是素数。

#### 例题

1. [204. 计数质数](https://leetcode.cn/problems/count-primes/)

```c++
// 204. 计数质数
int countPrimes(int n) {
    // 已经是质数的话，后面就不能出现质数的倍数了
    int res = 0;
    vector<bool> isPrime(n, true);
    for(int i = 2; i < n; ++i) {
        if(isPrime[i]) {
            ++res;    
            if((long long)i * i < n) {  //先把 i 临时转换成 long long，否则会溢出
                for(int j = i * i; j < n; j += i) {
                    isPrime[j] = false;
                }
            }
        }
    }

    return res;
}
```



### 丑数

例题：[剑指 Offer 49. 丑数](https://leetcode.cn/problems/chou-shu-lcof/)

思路：动态规划，由 $$num=2^i*3^j*5^k$$ ，每个丑数都可以由前一个丑数乘2/3/5得到，即 $$dp[i]=min(dp[i-1]*2,d[i-1]*3,dp[i-1]*5)$$ 

```c++
int nthUglyNumber(int n) {
    vector<int> nums(n, 1);
    int index2 = 0, index3 = 0, index5 = 0;
    for(int i = 1; i < n; ++i) {
        nums[i] = min(nums[index2] * 2, min(nums[index3] * 3, nums[index5] * 5));
        if(nums[index2] * 2 == nums[i]) {
            ++index2;
        }
        if(nums[index3] * 3 == nums[i]) {
            ++index3;
        }
        if(nums[index5] * 5 == nums[i]) {
            ++index5;
        }
    }

    return nums.back();
}
```



### 快乐数

例题：[202. 快乐数](https://leetcode.cn/problems/happy-number/)

思路：需要考虑两种情况，最终得到1和最终进入循环，可以考虑**哈希表判断循环**或者使用**循环链表的判断方法**，快慢指针！

```cpp
class Solution {
public:
    bool isHappy(int n) {
        int slow = n, fast = getSquareSum(n);

        while (true) {
            if (fast == 1)  return true;
            if (slow == fast)   return false;
            slow = getSquareSum(slow);
            fast = getSquareSum(getSquareSum(fast));
        }

        return false;
    }
private:
    int getSquareSum(int n) {
        int sum = 0;
        while (n != 0) {
            sum += (n % 10) * (n % 10);
            n /= 10;
        }
        return sum;
    }
};
```



### 大数运算

#### 大数相加





#### [大数相乘](https://leetcode.cn/problems/multiply-strings/)

![fig1](https://assets.leetcode-cn.com/solution-static/43/sol1.png)

1. 用底下数的每一位去乘以上面的数，然后求和

```cpp
class Solution {
public:
    string multiply(string num1, string num2) {
        if (num1 == "0" || num2 == "0") return "0";
        string res = "0";
        int m = num1.size(), n = num2.size();

        for (int i = n - 1; i >= 0; --i) {
            string cur = "";
            int carry = 0;
            // 补零
            for (int j = n - 1; j > i; --j) cur += '0';
            int y = num2[i] - '0';
            // 乘上面的数
            for (int j = m - 1; j >= 0; --j) {
                int x = num1[j] - '0';
                int temp = x * y + carry;
                cur += temp % 10 + '0';
                carry = temp / 10;
            }
            while (carry != 0) {
                cur += carry % 10 + '0';
                carry /= 10;
            }

            reverse(cur.begin(), cur.end());
            res = add(res, cur);
        }

        return res;
    }

private:
    string add(string num1, string num2) {
        int i = num1.size() - 1, j = num2.size() - 1, carry = 0;
        string res = "";
        while (i >= 0 || j >= 0 || carry != 0) {
            int x = 0, y = 0;
            if (i >= 0) x = num1[i] - '0';
            if (j >= 0) y = num2[j] - '0';
            int sum = x + y + carry;
            res += sum % 10 + '0';
            carry = sum / 10;
            --i;
            --j;
        }
        reverse(res.begin(), res.end());

        return res;
    }
};
```





#### 打印大数

例题：[剑指 Offer 17. 打印从1到最大的n位数](https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)

输入数字 `n`，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。

**思路：**

1. 模拟十进制数的加法运算
2. 全排列（回溯）

**要点：**

1. 需要考虑大数，即 n 可能超出 INT_MAX 的范围。需要用字符串表示；
2. 对字符串递增，需要模拟整数运算；
3. 输出字符串时需要先去除先导零



- **模拟加法**

```c++
bool addAndcheck(string& s) {
    bool isOverFlow = false;
    int carry = 0;
    for(int i = s.size() - 1; i >= 0; --i) {
        int cur = s[i] - '0' + carry;
        if(i == s.size() - 1)  // 加1
            ++cur;
        if(cur >= 10) {  // 产生进位
            if(i == 0)  isOverFlow = true;
            else {
                carry = 1;
                s[i] = (cur - 10) + '0';
            }
        }
        else {
            s[i] = cur + '0';
            break;
        }
    }

    return isOverFlow;
}

void printNum(string& s) {
    bool isBeginningZero = true;
    for(int i = 0; i < s.size(); ++i) {
        if(isBeginningZero && s[i] != '0') {
            isBeginningZero = false;
        }

        if(!isBeginningZero) {
            cout << s[i];
        }
    }
    cout << endl;
}

void PrintToMaxOfNdigits(int n) {
    if(n < 0)   return;
    string s(n, '0');
    while(!addAndcheck(s)) {
        printNum(s);
    }
}
```

- **排列（一眼回溯）**

```c++
void printNum(string& s) {
    bool isBeginningZero = true;
    for(int i = 0; i < s.size(); ++i) {
        if(isBeginningZero && s[i] != '0') {
            isBeginningZero = false;
        }

        if(!isBeginningZero) {
            cout << s[i];
        }
    }
    cout << endl;
}

void backtracking(string& path, int start, int length) {
    if(start == length) {
        printNum(path);
        return;
    }

    int cur = (start == 0 ? 1 : 0);
    for(int i = cur; i < 10; ++i) {
        path.push_back('0' + i);
        backtracking(path, start + 1, length);
        path.pop_back();
    }
}

void PrintToMaxOfNdigits(int n) {
    if(n < 0)   return;
    string s;
    for(int i = 1; i <= n; ++i) {
        backtracking(s, 0, i);
    }
}
```



#### 把数组排成最小的数

**例题**：[剑指 Offer 45. 把数组排成最小的数](https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)（华为一面）

**思路**：将两个数字转换为字符串m, n，则需要满足 m + n < n + m

```c++
string minNumber(vector<int>& nums) {
    sort(nums.begin(), nums.end(), [](const int& lhs, const int& rhs) {
        string s1 = to_string(lhs), s2 = to_string(rhs);
        return s1 + s2 < s2 + s1;
    });
    string res;
    for(const int& num : nums) {
        res += to_string(num);
    }

    return res;
}
```





### 判断一个字符串是否表示数值

**例题：**[剑指 Offer 20. 表示数值的字符串](https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/)

```c++
class Solution {
public:
    bool isNumber(string s) {
        // 一个数由：有符号整数部分 + '.' + 无符号整数部分 + 'e/E' + 有符号整数 组成
        int index = 0;
        // 跳过前导空格
        while(index < s.size() && s[index] == ' ') {
            ++index;
        }
        bool isValid = scanInt(s, index);
        if(s[index] == '.') {
            ++index;
            // '.'前后都可以没有数字
            // 所以用 |
            isValid |= scanUInt(s, index);
        }
        if(s[index] == 'e' || s[index] == 'E') { 
            ++index;
            // E前面和后面都有数字才有效
            // 所以用 &
            isValid &= scanInt(s, index);
        }

        // 跳过后面的空格
        while(index < s.size() && s[index] == ' ') {
            ++index;
        }

        return index == s.size() && isValid;
    }

private:
    bool scanInt(const string& s, int& index) {
        if(index >= s.size())   return false;

        if(s[index] == '+' || s[index] == '-') {
            ++index;
        }

        return scanUInt(s, index);
    }

    bool scanUInt(const string& s, int& index) {
        if(index >= s.size())   return false;

        int start = index;
        while(index < s.size() && s[index] >= '0' && s[index] <= '9') {
            ++index;
        }

        return index > start;
    }
    
};
```



# 常用库函数的实现



## 系统调用相关

### 实现 memcpy()

**实现要点**（类似 `strcpy()` ）：

1. 在函数入口处要检查源字符串指针和目标字符串指针是否有为空的，否则会产生不可预料的错误；
2. 如果按照一个字节拷贝，那就要把形参转换成 `char*` 类型来操作；
3. 要检查源内存和目标内存是否存在内存重叠，如果目标内存首地址在源内存的中间，则要从后往前拷贝，因为如果从前往后拷贝，那从目标内存首地址开始的地方就会被覆盖掉，如果没有重叠，或者源内存地址在目标内存的中间，那没有关系，可以从前往后拷贝；
4. 不能使用 `'\0'` 来判断拷贝的结束，因为它是对一整块内存的拷贝，举一个浅显的例子，假设拷贝一个结构体，类似上面代码，那么它很可能拷贝到中间的某个地方就停止了，这个拷贝就相当于没有完成；
5. 返回目标字符串的首地址；

```c++
// memcpy的实现1（一次拷贝一个字节）
void* mymemcpy(void* dest, const void* src, size_t n)
{
    if (dest == nullptr || src == nullptr)
          return nullptr;
    char *pDest = static_cast <char*>(dest);
    const char *pSrc = static_cast <const char*>(src);
    if (pDest > pSrc && pDest < pSrc + n) {  // 如果出现内存重叠的情况，从后往前复制
		pDest = pDest + n - 1;
        pSrc = pSrc + n - 1;
        
        while(n--)
            *pDest-- = *pSrc--;
    }
    else {  // 否则从前往后复制
		while(n--)
            *pDest++ = *pSrc++;
    }

    return dest;
}
```

- **如果面试官问，按照四个字节来拷贝，应该怎么处理？**

按照4个字节判断，一个清晰的思路是满足4个字节的按照 int 类型去拷贝，不满足4个字节的就还是按照 char 类型去拷贝。

如果按照4个字节来拷贝，就没办法去判断内存重叠的情况了，因为内存的基本单位是一个字节，4个字节是没有办法避免覆盖情况的。

```c++
// memcpy的实现1（一次拷贝四个字节）
void* mymemcpy(void* dest, const void* src, size_t n) {
    if (dest == NULL || src == NULL)
          return NULL;
    int *pDest = (int*)dest;
    int *pSrc = (int*)src;
    int iWordNum = n / 4;
    int iSlice = n % 4;
    while(iWordNum--) {
        *pDest++ = *pSrc++;
    }
    char* pcDest = (char*)pDest;
    char* pcSrc = (char*)pSrc;

    while(iSlice--) {
        *pcDest++ = *pcSrc++;
    }

    return dest;
}
```



## 字符串相关

### 实现strcpy()

把从strsrc地址开始且含有'\0'结束符的字符串复制到以strdest开始的地址空间，返回值的类型为char*

**注意的点：**

1. 源字符串使用const，避免被修改
2. 函数入口加入空指针判断
3. 返回值为`char*`，使函数支持链式表达式

**缺陷：**

1. 当src的长度超过dest的长度，导致数据写入未知内存->最好使用 `strncpy()`（用户自己声明拷贝多少个字符）

```c++
char* strcpy(char* dest, const char* src) {
    assert(dest != nullptr && src != nullptr);
    char* address = dest;
    while((*dest++ = *src++) != '\0');
    return address;
}

char* strncpy(char* dest, const char* src, size_t n) {
    assert(dest != nullptr && src != nullptr);
    char* ret = dest;
    while(n-- && (*dest++ = *src++) != '\0');
    return ret;
}
```



### 实现strStr()

```cpp
int strStr(string haystack, string needle) {
    // kmp 大法
    if (needle.size() == 0) return 0;
    if (haystack.size() < needle.size())    return -1;

    vector<int> next = getNext(needle);
    int j = -1;
    for (int i = 0; i < haystack.size(); ++i) {
        while (j >= 0 && haystack[i] != needle[j + 1]) {  // 前后缀不相同
            j = next[j];  // 回退
        }
        if (haystack[i] == needle[j + 1]) {  // 匹配的话，i和j同时向后移动
            ++j;
        }
        if (j + 1 == needle.size()) {  // 匹配完成
            return (i - j);
        }
    }

    return -1;
}


vector<int> getNext(const string& s) {
    vector<int> next(s.size(), 0);
    int j = -1;
    next[0] = j;
    for (int i = 1; i < s.size(); ++i) {
        while (j >= 0 && s[i] != s[j + 1]) {  // 前后缀不相同
            j = next[j];  // 回退
        }
        if (s[i] == s[j + 1]) {  // 找到相同的前后缀
            ++j;
        }
        next[i] = j;
    }

    return next;
}
```



### 实现strlen()

计算给定字符串的长度。

```c++
int strlen(const char* str) {
    assert(str != nullptr);
    int len;
    while(*str++ != '\0') {
        ++len;
    }
    return len;
}
```



### 实现strcat()

把src所指字符串添加到dest结尾处。

```c++
char* strcat(char* dest, const char* src) {
    assert(dest != nullptr && src != nullptr);
    char* ret = dest;
    // 找到dest的结尾
    while(*dest != '\o') {
        dest++;
    }
    while((*dest++ = *src++) != '\0') {}
    return ret;
}
```



### 实现strcmp()

比较两个字符串设这两个字符串为str1，str2

若`str1 == str2`，则返回零

若`str1 < str2`，则返回负数

若`str1 > str2`，则返回正数

```c++
int strcmp(const char* str1, const char* str2) {
    assert(str1 != nullptr && str2 != nullptr);
    // 找到首个不相等的字符
    while(*str1 != '\0' && *str2 != '\0' && *str1 == *str2) {
        str1++;
        str2++;
    }
    if(*str1 > *str2) {
        return 1;
    }
    else if(*str1 < *str2) {
        return -1;
    }
    else {
        return 0;
    }
}
```



### 实现atoi()

#### 实现要点

1. 删除前导空格
2. 检查正负号
3. 从第一个非空格字符开始转换（如果不是数字，直接返回0）
4. 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
5. 如果整数数超过 32 位有符号整数范围 [ $$−2^{31}$$ ,  $$2^{31} − 1$$ ] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 $$−2^{31}$$ 的整数应该被固定为 $$−2^{31}$$ ，大于 $$2^{31} − 1$$ 的整数应该被固定为 $$2^{31} − 1$$ 。

```c++
int myAtoi(string s) {
    int index = 0, n = s.size();
    bool negative = false;
    
    // 去除前导空格
    while (index < n && s[index] == ' ')    ++index;
    if (index == n) return 0;

    // 判断正负号
    if (s[index] == '-') {
        negative = true;
        ++index;
    }
    else if (s[index] == '+') {
        ++index;
    }

    int sum = 0;
    for (; index < n; ++index) {
        // s[index] 不为数字就终止
        if (s[index] < '0' || s[index] > '9')   break;
        if (sum > (INT_MAX - s[index] + '0') / 10) {  // 防止溢出
            return negative ? INT_MIN : INT_MAX;
        }
        sum = sum * 10 + s[index] - '0';
    }

    return negative ? -sum : sum;
}
```





# 智力题

## 智力题



### 101硬币，里面有1假币，用2次天平，判断假币更重还是更轻（阿里云）

第一次天平两边各放50个，会出现两种情况：
1. 平衡：那么剩下的肯定是假币，将它与真币对比即可
2. 不平衡：将其中一堆50个的分为两堆25的（如拿轻的），放天平两边，会出现两种情况：
    * 平衡：则假的在另一堆，假币更重
    * 不平衡：假的就在这堆，假币更轻

2、



### 64匹马，8个赛道，找出前四名最少需要比赛多少场？（腾讯、字节）

可不可以计时？ 可以->8场结束，不可以->老实分治

> 方法一

<img src="https://pic4.zhimg.com/80/v2-2aa7bc15744408f6e13e160ca1284a17_720w.jpg" alt="img"  />



> 方法二

<img src="https://pic4.zhimg.com/80/v2-3083b6b2ec82d2821612d4acff5a28e3_720w.jpg" alt="img" style="zoom:80%;" />

1. 每八匹马一组进行分组，然后按照分组进行比赛，淘汰每个小组的后面4名（8场）

   <img src="https://pic1.zhimg.com/80/v2-e8e4c01ebfab969c0a209e9615e7efd0_720w.jpg" alt="img" style="zoom:80%;" />

2. 然后每个小组的第一名进行比赛，淘汰后四名及其对应的小组（1场）

3. 此时已经可以知道第一名了，然后需要在剩下9匹马中找到最快的三匹马，将除D1以外8匹马进行比赛，此时有两种结果：

   - C1是第二名，那么D1可能是第三名，需要进行加赛
   - C1不是第二名，那么 D1不可能是第三名了，直接取比赛中的前三名



### 如何快速找出1000个瓶子中的一瓶毒药（微软、腾讯pcg）

> 这道题的描述方式很多，但都是万变不离其宗

1. 1000 个瓶子中有一瓶毒药，一只老鼠吃到毒药一周之内会死，如果要在一周之内检测出有毒药的一瓶，问至少需要几只老鼠？（并说出怎么检测）



> 基本思路

1000个药剂只有一个是毒药，所以有一千种状态。然后老鼠有两个状态（生/死），所以10只老鼠就可以表示 $$2^{10}=1024$$ 个状态。

- 把1000瓶标号：1,2,3,4,5,6...1000. `（十进制编号）` 。

- 所有老鼠排列在一起组成一个 `2进制` 队列: 0000000000。（0代表不喝，1代表喝 ）

  ```
  0000000001代表第一瓶水被喝情况
  0000000010代表第二瓶水被喝情况
  0000000011代表第三瓶水被喝情况
  0000000100代表第四瓶水被喝情况
  ...
  1111101000代表第1000瓶水被喝情况
  ```

- 第7天，喝了毒药的老鼠都死了，那个二进制队列转为为十进制就是毒药的标号。

  ```
  比如第3只老鼠死亡，其他老鼠没死，队列为0000000100，第4瓶水有毒。
  第1，5，6，8老鼠死亡，其他没死，队列为0010110001，第177瓶水有毒。
  ```

  





# 场景题

## 海量数据处理

### 海量手机号保存（百度二面）

> 如果有海量的手机号数据需要保存，但机器的性能有限，如何才能尽可能少的占用内存？

1. **手机号划分**

   **手机号依据字段的含义进行划分为三部分**，即 aaa-bbbb-cccc，其中前两个部分有特定的含义，如号段、区号等，而第三部分是随机的，所以手机号的前两个部分会有大量的重复，因此可对前两部分进行压缩，使用少数几个字符来表示。当然对于前面一致的部分可以考虑使用**前缀树**进行存储。

2. **存储偏移量**

   对号码进行**排序**，然后使每一个手机号减去最小的手机号得到一个差值，作为**偏移**，这样的话只需要记住最小的手机号和后面每个手机的偏移就可以了，这样可以大大减低内存占用。



### 重复/不重复数据 问题

#### 在海量数据中找到重复最多的一个

假设我们可以用的内存是64M，总的数据量是1024 * 64M即64G。

1. 预设多个小文件（如1024个）作为桶，每读到一条记录就进行哈希计算，将获得的哈希值余上 1024 ，将该记录放到对应的桶中。
2. 由于相同记录的哈希值相同，所以重复的数据一定放在同一个桶，在桶中记录数据的值和数量。
3. 当全部数据读取完成后，依次对所有子文件进行内部排序，如果内存允许的话，可以一次性把所有数据读到内存中进行快速排序，得到 1024 个桶内的最大重复记录。
4. 对这 1024 个桶的最大值进行比较（归并排序），获得最终的最大值就是重复最多的一个。

时间复杂度：O(N) + 100\*O(N1) + O(n\*logn)



#### 两个大文件中找出二者重复的数据

**具体描述：**

给定a、b两个文件，各存放50亿个url，每个 url 各占 64 字节，内存限制是 4G，找出a、b文件共同的 url

1. 假如每个url大小为 64 Bytes，那么可以估计每个文件的大小为 50G×64=320G，远远大于内存限制的4G，所以不可能将其完全加载到内存中处理，可以采用分治的思想来解决。
2. 遍历文件a，对每个url求取hash(url) % 1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,...,a999，每个小文件约300M）;
3. 遍历文件b，采取和 a 相同的方式将url分别存储到1000个小文件(记为b0,b1,...,b999)；
4. 由此，两个文件中相同的 url 一定在序号相同的小文件中，所以只需要找出相同序号文件中相同的 url 即可。
5. 把文件 ai 的 url 存储到 hash_set/hash_map 中。然后遍历 bi 的每个 url，看其是否在刚才构建的 hash_set 中，如果是，那么就是共同的 url，存到文件里面就可以了。



#### 海量数据中找出不重复的数字

- [ ] 位图

例如：2.5亿个整数中找出不重复的整数的个数。

思路： 用 2BitMap 表示一个数是否存在，32bit中无符号整数有4G个，共需 4G bits，每个字节8 bits，需要 2*4G/8 = 1G 字节。所以用 1GB 就可以表示所有的32位无符号整数的状态。

1. 申请 1G 内存，作为一个数是否存在的标记flag，全清0
2. 读入一个数，每个正整数用两个bit的标志位，00表示没有出现，01表示出现1次，10表示出现多次，11无意义
3. 重复2，直到所有整数处理完毕
4. 扫描位图，如果标志位为00（=0），则将对应位置的标志置为01（=1）。如果为01，则置为10（=2）。

也可以将 hash 划分小文件，小文件使用 hash_set 检查各个元素得到的。







### TOP K 问题

#### 10 亿个数中找出最大的 10000 个数

因为 10 亿个数没有办法全部读入内存，可以考虑使用**堆排序**。

**思路：**堆排序 + 分治优化

1. 先拿 10000 个数建小顶堆，然后依次添加剩余的数，如果大于堆顶的数，就将这个数替换堆顶的数，然后调整小根堆的结构。这样，遍历完后，堆中的10000个数就是所需的最大的10000个。
2. 优化：将 10 亿个数据分组存放，比如分别放在1000个文件中。这样处理就可以分别在每个文件的10^6个数据中找出最大的10000个数，合并到一起在再找出最终的结果（归并排序）。

时间复杂度：O(m*logm) + O(n\*m\*logm)



#### 如何从 5 亿个数中找出中位数？

从 5 亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。当样本数为奇数时，中位数为第 `(N+1)/2` 个数；当样本数为偶数时，中位数为第 `N/2` 个数与第 `1+N/2` 个数的均值。

思路：如果这道题没有内存大小限制，则可以把所有数读到内存中排序后找出中位数。但是最好的排序算法的时间复杂度都为 `O(NlogN)` 。这里使用其他方法。**双堆法（小量数据）或者分治法（大量数据）**。

**（1）双堆法**

维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数**小于等于**小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。若数据总数为**偶数**，当这两个堆建好之后，**中位数就是这两个堆顶元素的平均值**。当数据总数为**奇数**时，根据两个堆的大小，**中位数一定在数据多的堆的堆顶**。

**（2）分治法**

分治法的思想是把一个大的问题逐渐转换为规模较小的问题来求解。

对于这道题，顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的二进制中最高位为 1，则把这个数字写到 f1 中，否则写入 f0 中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。

划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。假设 f1 中有 1 亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5 亿个数与它后面的一个数的平均值。





## 限制常规思路的解题

#### [剑指 Offer 64. 求1+2+…+n](https://leetcode.cn/problems/qiu-12n-lcof/)

求 `1+2+...+n` ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

1. 利用构造函数（设置静态变量，每次构造对象都使 N + 1，SUM累加，构造 n 个对象即可）

2. 利用虚函数求解/函数指针求解

   - 基本思路是定义两个函数，当 n 不为 0 时调用第一个，n 为 0 时调用第二个
   - `!n` 可以使得 n 为 0 时，值为1（true）；n 不为零时，值为0（false）

3. 利用模板类型求解（编译期完成递归）

   ```c++
   template<int N>
   struct Factorial
   {
       enum { Value = N + Factorial<N - 1>::Value };
   };
   
   template<>
   struct Factorial<1>
   {
       enum { Value = 1 };
   };
   ```

4. 利用多维数组的大小来代替乘法

   ```c++
   // sizeof(a) = n * (n + 1) * 1 byte
   char a[n][n + 1];
   return sizeof(a) >> 1;
   ```



#### [剑指 Offer 65. 不用加减乘除做加法](https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)（腾讯and字节二面）

```c++
int add(int a, int b) {
    int sum = 0, carry = 0;
    do {
        sum = a ^ b;  // 非进位和（异或）
        carry = (unsigned int)(a & b) << 1;  // 计算进位（注意进位没有正负之分）
        a = sum;
        b = carry;
    }while(b != 0);

    return sum;
}
```





## 随机数问题

### 用一个随机数生成器实现另一个随机数生成器



### 建立无效数对有效数的映射，减小随机的次数

例题：

1. [710. 黑名单中的随机数](https://leetcode.cn/problems/random-pick-with-blacklist/)

- 题目的个人理解：

正常情况下 如果随机了一个数 这个数在黑名单中 那么需要重新随机一个数; 问题是 怎么能够减少随机的次数

- 换句话说：

如何处理能够在随机到黑名单中的值时 仍然能够将这个黑名单值转化为正常值

- 思路: 在[0,N)中有b个黑名单值， 我们可以在[0,N-b)的范围内取随机数

假设在【0，N-b】内有x个黑名单值 那么在[N-b,N)肯定有x个白名单值(非黑名单)

把这x个黑名单 和x个白名单一一对应 可以用map

那么 当取随机数r时 如果这个r在黑名单中 我们可以不需要再次进行取随机数 只要取map中r对应的白名单值就可以了



```c++
class Solution {
public:
    Solution(int n, vector<int>& blacklist) {
        _size = n - blacklist.size();
        unordered_set<int> black;

        for (int b : blacklist) {
            if (b >= _size) {
                black.emplace(b);
            }
        }

        int w = _size;
        for (int b : blacklist) {  // 建立黑名单对白名单的映射
            if (b < _size) {
                while (black.count(w) != 0) {  // 找处于范围外的白名单数字
                    ++w;
                }
                _b2w[b] = w++;
            }
        }
    }

    int pick() {
        int x = rand() % _size;
        return _b2w.count(x) > 0 ? _b2w[x] : x;
    }
    

private:
    int _size;
    unordered_map<int, int> _b2w;
};
```



## 加密问题

#### [设计 URL 简化算法](https://leetcode.cn/problems/encode-and-decode-tinyurl/)

TinyURL 是一种 URL 简化服务， 比如：当你输入一个 URL https://leetcode.com/problems/design-tinyurl 时，它将返回一个简化的URL http://tinyurl.com/4e9iAk 。请你设计一个类来加密与解密 TinyURL 。

思路：

1. **自增 ID**，每个 ID 对应一个 longURL
2. **设置哈希函数**，$$Hash(longUrl)=(\sum_{i=0}^{n-1}longUrl[i]×k_1^i)modk_2$$，但是需要解决哈希冲突的问题，解决方法可以考虑线性探测
3. **以随机数作为哈希键值**，使用一个随机生成的整数作为longUrl 的 key，如果 key 已经重复，那么不断尝试随机生成整数，直到key 唯一。
4. 方法三的优化，tinyurl 格式： [http://tinyurl.com/](https://leetcode.cn/link/?target=http%3A%2F%2Ftinyurl.com%2F) + 6位随机码(4e9iAK) 使用哈希表map, 加密的时候生成随机 tinyurl, 若 tinyurl 在 map中不存在, 则以 tinyurl 作为 key, url 作为value; 解密时, 通过 tinyurl 作为 key, 即可找到作为 value 的 url.

```cpp
class Solution {
public:
    // Encodes a URL to a shortened URL.
    string encode(string longUrl) {
        string key = "123456";
        while (true) {
            for (int i = 0; i < 6; ++i) {
                key[i] = INDEX[rand() % 62];
            }
            if (hash.count(key) == 0) {
                string shortUrl = TINYURL_PREFIX + key;
                hash[shortUrl] = longUrl;
                return shortUrl;
            }
        }
    }

    // Decodes a shortened URL to its original URL.
    string decode(string shortUrl) {
        return hash[shortUrl];
    }

private:
    unordered_map<string, string> hash;
    string INDEX = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    const string TINYURL_PREFIX = "http://tinyurl.com/";
};
```



# 设计题

## 栈相关

### 最小栈的实现

基本功能与栈相同，但是多了一个 `getMin()` 获取最小值

**例题：**[155. 最小栈](https://leetcode.cn/problems/min-stack/)

**基本思路：**

- 两个栈（一个实现栈的基本功能，一个存放最小值）
- 一个栈
  - 栈内放的是 `pair<int, int>` 第一个是放入的元素，第二个是最小值
  - 栈内放的是 `当前元素 - 最小值` 
- 直接使用链表，链表内存放当前元素和最小值



```c++
// 栈内存放插值
class MinStack {
public:
    stack<long long> stk;
    long long diff;
    long long min;
    bool block=true;   //是否是在栈为空的时候进行push
    MinStack() {
    }
    
    void push(int val) {
        if(block&&val>0){
            min=INT_MAX;       //栈为空且val>0时，min的初始值为INT_MAX
            block=false;       //上锁
        }
        else if(block&&val<=0){
            min=0;
            block=false;
        }
        diff=(long long)val-min;
        stk.push(diff);
        stk.push(val);
        if(diff<0)          //若diff<0,则说明push的值是当前最小值
            min=val;
    }
    
    void pop() {
        int top=stk.top();   //栈顶元素的值
        stk.pop();
        int d=stk.top();    //属于栈顶元素的diff
        stk.pop();
        min=(long long)top-d;    //更新当前最小值(若pop的元素不是最小值，其实min是不变的)
        if(stk.empty()) block=true;    //若出栈导致栈空，则解锁
    }
    
    int top() {
        return stk.top();
    }
    
    int getMin() {
        return min;
    }
};
```



```java
// 链表
class MinStack {
    class Node{
        int value;
        int min;
        Node* next;

        Node(int x, int min){
            this.value=x;
            this.min=min;
            next = null;
        }
    }
    Node head;
    //每次加入的节点放到头部
    public void push(int x) {
        if(null==head){
            head = new Node(x,x);
        }else{
            //当前值和之前头结点的最小值较小的做为当前的 min
            Node n = new Node(x, Math.min(x,head.min));
            n.next=head;
            head=n;
        }
    }

    public void pop() {
        if(head!=null)
            head =head.next;
    }

    public int top() {
        if(head!=null)
            return head.value;
        return -1;
    }

    public int getMin() {
        if(null!=head)
            return head.min;
        return -1;
    }
}
```







## 队列相关

### 实现循环队列（RingBuffer）

例题：

1. [622. 设计循环队列](https://leetcode.cn/problems/design-circular-queue/)（链表/循环数组）

```cpp
class MyCircularQueue {
public:
    MyCircularQueue(int k) : buffer(k + 1, 0), size(k + 1), readIndex(0), writeIndex(0) {

    }
    
    bool enQueue(int value) {
        if (isFull())   return false;

        buffer[writeIndex] = value;
        writeIndex = (writeIndex + 1) % size;
        return true;
    }
    
    bool deQueue() {
        if (isEmpty())  return false;

        readIndex = (readIndex + 1) % size;
        return true;
    }
    
    int Front() {
        if (isEmpty())  return -1;

        return buffer[readIndex];
    }
    
    int Rear() {
        if (isEmpty())  return -1;

        return buffer[(writeIndex - 1 + size) % size];
    }
    
    bool isEmpty() {
        return readIndex == writeIndex;
    }
    
    bool isFull() {
        return readIndex == (writeIndex + 1) % size;
    }

private:
    vector<int> buffer;
    int size;
    int readIndex, writeIndex;
};
```



## 链表相关

### LFU

### LRU

### 跳表

例题：[1206. 设计跳表](https://leetcode.cn/problems/design-skiplist/)









# 性能测试问题

## 耗时测量

### 测试某个函数的耗时

```cpp
#include <iostream>
#include <chrono>
#include <thread>
using namespace std;
using namespace chrono;
// O(n)
void function1(long long n) {
    long long k = 0;
    for (long long i = 0; i < n; i++) {
        k++;
    }
}

// O(n^2)
void function2(long long n) {
    long long k = 0;
    for (long long i = 0; i < n; i++) {
        for (long j = 0; j < n; j++) {
            k++;
        }
    }

}
// O(nlogn)
void function3(long long n) {
    long long k = 0;
    for (long long i = 0; i < n; i++) {
        for (long long j = 1; j < n; j = j*2) { // 注意这里j=1
            k++;
        }
    }
}
int main() {
    long long n; // 数据规模
    while (1) {
        cout << "输入n：";
        cin >> n;
        milliseconds start_time = duration_cast<milliseconds >(
            system_clock::now().time_since_epoch()
        );
        function1(n);
//        function2(n);
//        function3(n);
        milliseconds end_time = duration_cast<milliseconds >(
            system_clock::now().time_since_epoch()
        );
        cout << "耗时:" << milliseconds(end_time).count() - milliseconds(start_time).count()
            <<" ms"<< endl;
    }
}
```
